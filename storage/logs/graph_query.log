2025-12-02 15:39:55,105 - __main__ - INFO - 成功连接到 Neo4j: neo4j://0.0.0.0:7474
2025-12-02 15:40:20,896 - __main__ - INFO - Neo4j 连接已关闭
2025-12-02 15:40:39,439 - __main__ - INFO - 成功连接到 Neo4j: neo4j://0.0.0.0:7474
2025-12-02 15:55:51,398 - __main__ - INFO - 收到生成查询请求: 感冒了应该吃什么治疗
2025-12-02 15:55:51,800 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 15:55:54,161 - __main__ - INFO - 生成的 Cypher 查询: ```cypher
MATCH (d:Disease)-[r:do_eat]->(f:Food) 
WHERE d.name = '感冒' 
RETURN f.name
```
2025-12-02 15:55:54,200 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 15:56:04,385 - __main__ - INFO - 查询解释: 这个Cypher查询的作用是：**查找感冒患者应该吃的食物**。

让我一步步解释：

1. **`MATCH (d:Disease)-[r:do_eat]->(f:Food)`**
   - 在图中查找这样的关系模式：
   - `d` 代表疾病节点（标签是 `Disease`）
   - `f` 代表食物节点（标签是 `Food`）
   - `r` 是它们之间的关系，类型是 `do_eat`（表示"应该吃"）

2. **`WHERE d.name = '感冒'`**
   - 只选择疾病名称为"感冒"的节点

3. **`RETURN f.name`**
   - 返回所有与"感冒"相关的食物的名称

**简单来说**：这个查询就像在问："感冒了应该吃什么食物？" 然后从图数据库中找出所有答案。

**实际应用场景**：这可以用于医疗健康应用，为用户提供饮食建议。数据库里存储了各种疾病和对应推荐食物的关系。
2025-12-02 15:56:04,386 - __main__ - INFO - 查询验证通过
2025-12-02 15:58:26,512 - __main__ - INFO - 收到生成查询请求: 高血压患者饮食要注意什么？
2025-12-02 15:58:26,606 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 15:58:28,940 - __main__ - INFO - 生成的 Cypher 查询: ```cypher
MATCH (p:Disease)-[r:not_eat]-(f:Food) 
WHERE p.name='高血压' 
RETURN f.name
```
2025-12-02 15:58:28,979 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 15:58:38,954 - __main__ - INFO - 查询解释: 这个Cypher查询的意思是：

**"找出高血压患者不能吃的食物"**

让我详细解释一下：

1. **`MATCH (p:Disease)-[r:not_eat]-(f:Food)`**
   - 在图中查找一个疾病节点（`p`）和一个食物节点（`f`）
   - 它们之间通过"不能吃"（`not_eat`）的关系连接
   - `p` 代表疾病，`f` 代表食物

2. **`WHERE p.name='高血压'`**
   - 只选择疾病名称为"高血压"的节点

3. **`RETURN f.name`**
   - 返回所有与高血压有"不能吃"关系的食物的名称

**简单来说**：这个查询在知识图谱中查找与"高血压"疾病相关联的、需要避免的食物列表，然后返回这些食物的名字。

比如查询结果可能是：高盐食物、腌制食品、肥肉等高血压患者应该避免的食物名称。
2025-12-02 15:58:38,955 - __main__ - INFO - 查询验证通过
2025-12-02 15:59:34,380 - __main__ - INFO - 收到生成查询请求: 高血压患者饮食要注意什么？
2025-12-02 15:59:34,504 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 15:59:37,330 - __main__ - INFO - 生成的 Cypher 查询: ```cypher
MATCH (p:Disease)-[r:not_eat]-(f:Food) 
WHERE p.name='高血压' 
RETURN f.name
```
2025-12-02 15:59:37,383 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 15:59:47,906 - __main__ - INFO - 查询解释: 这个Cypher查询的意思是：

**查找高血压患者不应该吃的食物**

让我详细解释一下：

1. **`MATCH (p:Disease)-[r:not_eat]-(f:Food)`**
   - 在图中查找一个模式：一个疾病节点（标签为"Disease"）通过"not_eat"关系连接到一个食物节点（标签为"Food"）
   - `p` 代表疾病节点
   - `f` 代表食物节点
   - `r` 代表它们之间的"not_eat"关系

2. **`WHERE p.name='高血压'`**
   - 只选择疾病名称为"高血压"的节点

3. **`RETURN f.name`**
   - 返回所有与高血压有"not_eat"关系的食物的名称

**简单来说**：这个查询在知识图谱中查找高血压患者不应该吃的所有食物，并返回这些食物的名称列表。

**实际应用场景**：这可以用于医疗健康应用，当用户查询高血压的饮食禁忌时，系统可以快速返回相关的食物建议。
2025-12-02 15:59:47,906 - __main__ - INFO - 查询验证通过
2025-12-02 16:04:54,308 - __main__ - INFO - 收到生成查询请求: 高血压患者饮食要注意什么？
2025-12-02 16:04:54,408 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 16:04:56,632 - __main__ - INFO - 生成的 Cypher 查询: ```cypher
MATCH (p:Disease)-[r:not_eat]-(f:Food) 
WHERE p.name='高血压' 
RETURN f.name
```
2025-12-02 16:04:56,673 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 16:05:06,211 - __main__ - INFO - 查询解释: 这个Cypher查询的意思是：

**查找高血压患者不应该吃的食物**

让我详细解释一下：

1. **`MATCH (p:Disease)-[r:not_eat]-(f:Food)`**
   - 在图中查找一个疾病节点（标签为`Disease`）和一个食物节点（标签为`Food`）
   - 这两个节点之间通过`not_eat`关系连接
   - `p`代表疾病节点，`f`代表食物节点，`r`代表它们之间的关系

2. **`WHERE p.name='高血压'`**
   - 只选择疾病名称为"高血压"的节点

3. **`RETURN f.name`**
   - 返回所有与高血压有`not_eat`关系的食物的名称

**简单来说**：这个查询在知识图谱中找出所有高血压患者不应该吃的食物名称。

**实际应用场景**：这可以用于医疗健康应用，当用户查询高血压时，系统可以给出饮食禁忌建议。
2025-12-02 16:05:06,211 - __main__ - INFO - 查询验证通过
2025-12-02 16:05:06,223 - __main__ - INFO - 收到验证查询请求: ```cypher
MATCH (p:Disease)-[r:not_eat]-(f:Food) 
WHERE p.name='高血压' 
RETURN f.name
```
2025-12-02 16:05:06,223 - __main__ - INFO - 查询验证通过
2025-12-02 16:05:06,232 - __main__ - INFO - 收到执行查询请求: ```cypher
MATCH (p:Disease)-[r:not_eat]-(f:Food) 
WHERE p.name='高血压' 
RETURN f.name
```
2025-12-02 16:05:06,232 - __main__ - INFO - 执行 Cypher 查询: ```cypher
MATCH (p:Disease)-[r:not_eat]-(f:Food) 
WHERE p.name='高血压' 
RETURN f.name
```
2025-12-02 16:05:06,296 - neo4j.pool - ERROR - Unable to retrieve routing information
2025-12-02 16:05:06,297 - __main__ - ERROR - 查询执行失败，耗时: 0.064秒，错误: Unable to retrieve routing information
2025-12-02 16:06:31,721 - __main__ - INFO - Neo4j 连接已关闭
2025-12-02 16:06:36,809 - __main__ - INFO - 成功连接到 Neo4j: bolt://localhost:7687
2025-12-02 16:06:45,659 - __main__ - INFO - 收到生成查询请求: 高血压患者饮食要注意什么？
2025-12-02 16:06:46,022 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 16:06:48,650 - __main__ - INFO - 生成的 Cypher 查询: ```cypher
MATCH (p:Disease)-[r:not_eat]-(f:Food) 
WHERE p.name='高血压' 
RETURN f.name
```
2025-12-02 16:06:48,728 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 16:06:59,046 - __main__ - INFO - 查询解释: 这个Cypher查询的意思是：

**查找高血压患者不应该吃的食物**

让我详细解释一下：

1. **`MATCH (p:Disease)-[r:not_eat]-(f:Food)`**
   - 在图中查找一个模式：一个疾病节点（标签为"Disease"）通过"not_eat"关系连接到一个食物节点（标签为"Food"）
   - `p` 代表疾病节点
   - `f` 代表食物节点
   - `r` 代表它们之间的"not_eat"关系

2. **`WHERE p.name='高血压'`**
   - 只选择疾病名称为"高血压"的节点

3. **`RETURN f.name`**
   - 返回所有与高血压有"not_eat"关系的食物的名称

**简单来说**：这个查询在知识图谱中查找高血压患者不应该吃的所有食物，并返回这些食物的名称列表。

**实际应用场景**：这可以用于医疗健康应用，当用户查询高血压的饮食禁忌时，系统可以快速返回相关的食物建议。
2025-12-02 16:06:59,048 - __main__ - INFO - 查询验证通过
2025-12-02 16:06:59,062 - __main__ - INFO - 收到验证查询请求: ```cypher
MATCH (p:Disease)-[r:not_eat]-(f:Food) 
WHERE p.name='高血压' 
RETURN f.name
```
2025-12-02 16:06:59,063 - __main__ - INFO - 查询验证通过
2025-12-02 16:06:59,071 - __main__ - INFO - 收到执行查询请求: ```cypher
MATCH (p:Disease)-[r:not_eat]-(f:Food) 
WHERE p.name='高血压' 
RETURN f.name
```
2025-12-02 16:06:59,071 - __main__ - INFO - 执行 Cypher 查询: ```cypher
MATCH (p:Disease)-[r:not_eat]-(f:Food) 
WHERE p.name='高血压' 
RETURN f.name
```
2025-12-02 16:06:59,163 - __main__ - ERROR - 查询执行失败，耗时: 0.092秒，错误: {code: Neo.ClientError.Statement.SyntaxError} {message: Invalid input '```cypher\nMATCH (p:Disease)-[r:not_eat]-(f:Food) \nWHERE p.name='高血压' \nRETURN f.name\n```': expected 'FOREACH', 'ALTER', 'ORDER BY', 'CALL', 'USING PERIODIC COMMIT', 'CREATE', 'LOAD CSV', 'START DATABASE', 'STOP DATABASE', 'DEALLOCATE', 'DELETE', 'DENY', 'DETACH', 'DROP', 'DRYRUN', 'FINISH', 'GRANT', 'INSERT', 'LIMIT', 'MATCH', 'MERGE', 'NODETACH', 'OFFSET', 'OPTIONAL', 'REALLOCATE', 'REMOVE', 'RENAME', 'RETURN', 'REVOKE', 'ENABLE SERVER', 'SET', 'SHOW', 'SKIP', 'TERMINATE', 'UNWIND', 'USE' or 'WITH' (line 1, column 1 (offset: 0))
"```cypher"
 ^}
2025-12-02 16:07:18,533 - __main__ - INFO - Neo4j 连接已关闭
2025-12-02 16:07:22,152 - __main__ - INFO - 成功连接到 Neo4j: bolt://localhost:7687
2025-12-02 16:07:25,904 - __main__ - INFO - 收到生成查询请求: 高血压患者饮食要注意什么？
2025-12-02 16:07:26,284 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 16:07:29,090 - __main__ - INFO - 生成的 Cypher 查询: ```cypher
MATCH (p:Disease)-[r:not_eat]-(f:Food) 
WHERE p.name='高血压' 
RETURN f.name
```
2025-12-02 16:07:29,136 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 16:07:39,485 - __main__ - INFO - 查询解释: 这个Cypher查询的意思是：

**"找出高血压患者不能吃的食物"**

让我一步步解释：

1. **`MATCH (p:Disease)-[r:not_eat]-(f:Food)`**
   - 在图中查找模式：一个疾病节点（标签为`Disease`）通过`not_eat`关系连接到一个食物节点（标签为`Food`）
   - `p`代表疾病节点，`f`代表食物节点，`r`代表它们之间的关系

2. **`WHERE p.name='高血压'`**
   - 筛选条件：只选择名称为"高血压"的疾病节点

3. **`RETURN f.name`**
   - 返回结果：只返回食物节点的名称

**简单来说**：这个查询在知识图谱中查找与"高血压"疾病有"不能吃"关系的所有食物，并返回这些食物的名称。

**实际应用场景**：比如在医疗健康应用中，当用户查询高血压的饮食禁忌时，系统可以用这个查询找出所有高血压患者应该避免的食物。
2025-12-02 16:07:39,487 - __main__ - INFO - 查询验证通过
2025-12-02 16:07:39,501 - __main__ - INFO - 收到验证查询请求: ```cypher
MATCH (p:Disease)-[r:not_eat]-(f:Food) 
WHERE p.name='高血压' 
RETURN f.name
```
2025-12-02 16:07:39,501 - __main__ - INFO - 查询验证通过
2025-12-02 16:07:39,509 - __main__ - INFO - 收到执行查询请求: ```cypher
MATCH (p:Disease)-[r:not_eat]-(f:Food) 
WHERE p.name='高血压' 
RETURN f.name
```
2025-12-02 16:07:39,516 - __main__ - INFO - 执行 Cypher 查询: ```cypher
MATCH (p:Disease)-[r:not_eat]-(f:Food) 
WHERE p.name='高血压' 
RETURN f.name
```
2025-12-02 16:07:39,570 - __main__ - ERROR - 查询执行失败，耗时: 0.052秒，错误: {code: Neo.ClientError.Statement.SyntaxError} {message: Invalid input '```cypher\nMATCH (p:Disease)-[r:not_eat]-(f:Food) \nWHERE p.name='高血压' \nRETURN f.name\n```': expected 'FOREACH', 'ALTER', 'ORDER BY', 'CALL', 'USING PERIODIC COMMIT', 'CREATE', 'LOAD CSV', 'START DATABASE', 'STOP DATABASE', 'DEALLOCATE', 'DELETE', 'DENY', 'DETACH', 'DROP', 'DRYRUN', 'FINISH', 'GRANT', 'INSERT', 'LIMIT', 'MATCH', 'MERGE', 'NODETACH', 'OFFSET', 'OPTIONAL', 'REALLOCATE', 'REMOVE', 'RENAME', 'RETURN', 'REVOKE', 'ENABLE SERVER', 'SET', 'SHOW', 'SKIP', 'TERMINATE', 'UNWIND', 'USE' or 'WITH' (line 1, column 1 (offset: 0))
"```cypher"
 ^}
2025-12-02 16:11:25,506 - __main__ - INFO - Neo4j 连接已关闭
2025-12-02 16:11:29,597 - __main__ - INFO - 成功连接到 Neo4j: bolt://localhost:7687
2025-12-02 16:11:34,478 - __main__ - INFO - 收到生成查询请求: 高血压患者饮食要注意什么？
2025-12-02 16:11:34,903 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 16:11:37,604 - __main__ - INFO - 生成的 Cypher 查询: MATCH (p:Disease)-[r:not_eat]-(f:Food) 
WHERE p.name='高血压' 
RETURN f.name
2025-12-02 16:11:37,656 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 16:11:48,637 - __main__ - INFO - 查询解释: 这个Cypher查询是用来查找高血压患者不应该吃的食物。让我一步步解释：

**查询结构：**
1. **MATCH (p:Disease)-[r:not_eat]-(f:Food)**
   - 在图中查找所有疾病节点（标签为"Disease"）和食物节点（标签为"Food"）之间的关系
   - 关系类型是"not_eat"（不应该吃）
   - 疾病节点用变量`p`表示，食物节点用变量`f`表示，关系用变量`r`表示

2. **WHERE p.name='高血压'**
   - 筛选条件：只选择疾病名称为"高血压"的节点

3. **RETURN f.name**
   - 返回结果：只返回食物的名称

**简单来说：**
这个查询的意思是："找出所有高血压患者不应该吃的食物名称"

**查询结果：**
会返回一个食物名称的列表，这些食物都是高血压患者应该避免食用的。

**实际应用场景：**
这种查询可以用于医疗健康应用、饮食建议系统等，帮助高血压患者了解哪些食物对他们的病情不利。
2025-12-02 16:11:48,639 - __main__ - INFO - 查询验证通过
2025-12-02 16:11:48,653 - __main__ - INFO - 收到验证查询请求: MATCH (p:Disease)-[r:not_eat]-(f:Food) 
WHERE p.name='高血压' 
RETURN f.name
2025-12-02 16:11:48,654 - __main__ - INFO - 查询验证通过
2025-12-02 16:11:48,659 - __main__ - INFO - 收到执行查询请求: MATCH (p:Disease)-[r:not_eat]-(f:Food) 
WHERE p.name='高血压' 
RETURN f.name
2025-12-02 16:11:48,659 - __main__ - INFO - 执行 Cypher 查询: MATCH (p:Disease)-[r:not_eat]-(f:Food) 
WHERE p.name='高血压' 
RETURN f.name
2025-12-02 16:11:48,775 - __main__ - INFO - 查询执行成功，耗时: 0.115秒，返回 4 条记录
2025-12-02 16:11:48,775 - __main__ - INFO - 查询结果: [{'f.name': '杏仁'}, {'f.name': '咸鸭蛋'}, {'f.name': '腐竹'}, {'f.name': '鸡肝'}]
2025-12-02 16:11:48,775 - __main__ - INFO - 查询执行完成，返回 4 条记录
2025-12-02 16:15:26,957 - __main__ - INFO - 收到生成查询请求: 高血压患者饮食要注意什么？
2025-12-02 16:15:27,057 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 16:15:29,389 - __main__ - INFO - 生成的 Cypher 查询: MATCH (p:Disease)-[r:not_eat]-(f:Food) 
WHERE p.name='高血压' 
RETURN f.name
2025-12-02 16:15:29,444 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 16:15:40,512 - __main__ - INFO - 查询解释: 这个Cypher查询是用来查找高血压患者不应该吃的食物。让我一步步解释：

**查询结构：**
1. **MATCH (p:Disease)-[r:not_eat]-(f:Food)**
   - 在图中查找所有疾病节点（标签为"Disease"）和食物节点（标签为"Food"）之间的关系
   - 关系类型是"not_eat"（不应该吃）
   - 疾病节点用变量`p`表示，食物节点用变量`f`表示，关系用变量`r`表示

2. **WHERE p.name='高血压'**
   - 筛选条件：只选择疾病名称为"高血压"的节点

3. **RETURN f.name**
   - 返回结果：只返回食物的名称

**简单来说：**
这个查询的意思是："找出所有高血压患者不应该吃的食物名称"

**查询结果示例：**
可能会返回类似这样的食物列表：
- 咸菜
- 肥肉
- 动物内脏
- 高盐食品
- ...

这个查询假设你的图数据库中已经建立了疾病和食物之间的"不应该吃"关系，并且有高血压这个疾病节点。
2025-12-02 16:15:40,514 - __main__ - INFO - 查询验证通过
2025-12-02 16:15:40,524 - __main__ - INFO - 收到验证查询请求: MATCH (p:Disease)-[r:not_eat]-(f:Food) 
WHERE p.name='高血压' 
RETURN f.name
2025-12-02 16:15:40,524 - __main__ - INFO - 查询验证通过
2025-12-02 16:15:40,529 - __main__ - INFO - 收到执行查询请求: MATCH (p:Disease)-[r:not_eat]-(f:Food) 
WHERE p.name='高血压' 
RETURN f.name
2025-12-02 16:15:40,529 - __main__ - INFO - 执行 Cypher 查询: MATCH (p:Disease)-[r:not_eat]-(f:Food) 
WHERE p.name='高血压' 
RETURN f.name
2025-12-02 16:15:40,567 - __main__ - INFO - 查询执行成功，耗时: 0.038秒，返回 4 条记录
2025-12-02 16:15:40,568 - __main__ - INFO - 查询结果: [{'f.name': '杏仁'}, {'f.name': '咸鸭蛋'}, {'f.name': '腐竹'}, {'f.name': '鸡肝'}]
2025-12-02 16:15:40,568 - __main__ - INFO - 查询执行完成，返回 4 条记录
2025-12-02 16:19:52,383 - __main__ - INFO - 收到生成查询请求: 高血压患者饮食要注意什么？
2025-12-02 16:19:52,524 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 16:19:55,379 - __main__ - INFO - 生成的 Cypher 查询: MATCH (p:Disease)-[r:not_eat]-(f:Food) 
WHERE p.name='高血压' 
RETURN f.name
2025-12-02 16:19:55,438 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 16:20:05,848 - __main__ - INFO - 查询解释: 这个Cypher查询是用来查找高血压患者不应该吃的食物。让我一步步解释：

**查询结构：**
1. **MATCH (p:Disease)-[r:not_eat]-(f:Food)**
   - 在图中查找所有疾病节点（标签为"Disease"）和食物节点（标签为"Food"）之间的关系
   - 关系类型是"not_eat"（不应该吃）
   - 疾病节点用变量`p`表示，食物节点用变量`f`表示

2. **WHERE p.name='高血压'**
   - 筛选条件：只选择疾病名称为"高血压"的节点

3. **RETURN f.name**
   - 返回结果：只返回食物的名称

**简单来说：**
这个查询的意思是："找出所有高血压患者不应该吃的食物名称"

**查询结果：**
会返回一个食物名称的列表，这些食物都是高血压患者应该避免食用的。

**实际应用场景：**
这种查询在健康管理、医疗建议系统中很有用，可以帮助高血压患者了解饮食禁忌。
2025-12-02 16:20:05,850 - __main__ - INFO - 查询验证通过
2025-12-02 16:20:05,862 - __main__ - INFO - 收到验证查询请求: MATCH (p:Disease)-[r:not_eat]-(f:Food) 
WHERE p.name='高血压' 
RETURN f.name
2025-12-02 16:20:05,862 - __main__ - INFO - 查询验证通过
2025-12-02 16:20:05,867 - __main__ - INFO - 收到执行查询请求: MATCH (p:Disease)-[r:not_eat]-(f:Food) 
WHERE p.name='高血压' 
RETURN f.name
2025-12-02 16:20:05,867 - __main__ - INFO - 执行 Cypher 查询: MATCH (p:Disease)-[r:not_eat]-(f:Food) 
WHERE p.name='高血压' 
RETURN f.name
2025-12-02 16:20:05,909 - __main__ - INFO - 查询执行成功，耗时: 0.042秒，返回 4 条记录
2025-12-02 16:20:05,909 - __main__ - INFO - 查询结果: [{'f.name': '杏仁'}, {'f.name': '咸鸭蛋'}, {'f.name': '腐竹'}, {'f.name': '鸡肝'}]
2025-12-02 16:20:05,909 - __main__ - INFO - 查询执行完成，返回 4 条记录
2025-12-02 16:20:58,465 - __main__ - INFO - 收到生成查询请求: 嗓子疼，感觉感觉自己好像是感冒了，应该吃什么，去那个科室看看医生？
2025-12-02 16:20:58,598 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 16:21:06,529 - __main__ - INFO - 生成的 Cypher 查询: // 首先查找与"感冒"相关的疾病信息
MATCH (d:Disease)
WHERE d.name CONTAINS '感冒'
WITH d
// 查找推荐药物
OPTIONAL MATCH (d)-[:recommand_drug]->(drug:Drug)
// 查找推荐食物
OPTIONAL MATCH (d)-[:recommand_eat]->(food:Food)
// 查找所属科室
OPTIONAL MATCH (d)-[:belongs_to]->(dept:Department)
RETURN 
    d.name AS disease_name,
    d.desc AS description,
    COLLECT(DISTINCT drug.name) AS recommended_drugs,
    COLLECT(DISTINCT food.name) AS recommended_foods,
    COLLECT(DISTINCT dept.name) AS departments
2025-12-02 16:21:06,598 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 16:21:31,826 - __main__ - INFO - 查询解释: 这个Cypher查询用于从医疗知识图谱中查找与"感冒"相关的疾病信息及其关联数据。让我分步解释：

## 查询目的
查找名称中包含"感冒"的疾病，并获取其推荐药物、推荐食物和所属科室信息。

## 查询步骤分解：

1. **查找疾病节点**
   ```cypher
   MATCH (d:Disease)
   WHERE d.name CONTAINS '感冒'
   ```
   - 匹配所有标签为"Disease"的节点
   - 筛选出名称中包含"感冒"的疾病（如"普通感冒"、"流行性感冒"等）

2. **查找推荐药物**
   ```cypher
   OPTIONAL MATCH (d)-[:recommand_drug]->(drug:Drug)
   ```
   - 使用`OPTIONAL MATCH`查找从疾病节点指向药物节点的`recommand_drug`关系
   - `OPTIONAL`表示即使没有相关药物，查询也会继续执行

3. **查找推荐食物**
   ```cypher
   OPTIONAL MATCH (d)-[:recommand_eat]->(food:Food)
   ```
   - 查找从疾病节点指向食物节点的`recommand_eat`关系

4. **查找所属科室**
   ```cypher
   OPTIONAL MATCH (d)-[:belongs_to]->(dept:Department)
   ```
   - 查找从疾病节点指向科室节点的`belongs_to`关系

5. **返回结果**
   ```cypher
   RETURN 
       d.name AS disease_name,
       d.desc AS description,
       COLLECT(DISTINCT drug.name) AS recommended_drugs,
       COLLECT(DISTINCT food.name) AS recommended_foods,
       COLLECT(DISTINCT dept.name) AS departments
   ```
   - 返回疾病名称和描述
   - 使用`COLLECT(DISTINCT ...)`将多个相关值聚合为列表
   - 去除重复值（`DISTINCT`）

## 查询结果示例
可能会返回类似这样的结果：
```
{
  disease_name: "流行性感冒",
  description: "由流感病毒引起的急性呼吸道传染病",
  recommended_drugs: ["奥司他韦", "布洛芬", "对乙酰氨基酚"],
  recommended_foods: ["姜茶", "鸡汤", "蜂蜜柠檬水"],
  departments: ["呼吸内科", "感染科"]
}
```

## 关键特点
- 使用`OPTIONAL MATCH`确保即使某些关系不存在，查询也能返回疾病基本信息
- `COLLECT()`函数将多个匹配项聚合为数组
- `DISTINCT`确保结果中没有重复值
- 查询结构清晰，便于理解数据关系

这个查询非常适合构建医疗咨询系统，为用户提供全面的疾病相关信息。
2025-12-02 16:21:31,829 - __main__ - WARNING - 查询验证发现错误: ['使用了不存在的节点标签: d', '使用了不存在的节点标签: d', '使用了不存在的节点标签: d']
2025-12-02 16:21:31,836 - __main__ - INFO - 收到生成查询请求: 嗓子疼，感觉感觉自己好像是感冒了，应该吃什么，去那个科室看看医生？
2025-12-02 16:21:31,915 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 16:21:41,148 - __main__ - INFO - 生成的 Cypher 查询: // 首先查找与"感冒"相关的疾病信息
MATCH (d:Disease)
WHERE d.name CONTAINS '感冒'
WITH d
// 查找推荐药物
OPTIONAL MATCH (d)-[:recommand_drug]->(drug:Drug)
// 查找所属科室
OPTIONAL MATCH (d)-[:belongs_to]->(dept:Department)
RETURN 
    d.name AS disease_name,
    d.desc AS description,
    d.prevent AS prevention,
    d.cause AS cause,
    d.easy_get AS susceptible_population,
    d.cure_way AS treatment_method,
    d.cure_department AS recommended_department,
    d.cure_lasttime AS treatment_duration,
    d.cured_prob AS cure_probability,
    COLLECT(DISTINCT drug.name) AS recommended_drugs,
    COLLECT(DISTINCT dept.name) AS departments
2025-12-02 16:21:41,265 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 16:22:06,429 - __main__ - INFO - 查询解释: 我来解释这个Cypher查询，它用于从医疗知识图谱中查找与"感冒"相关的疾病信息：

## 查询目的
查找名称中包含"感冒"的疾病，并获取其详细信息、推荐药物和所属科室。

## 查询步骤分解：

### 1. 查找疾病节点
```cypher
MATCH (d:Disease)
WHERE d.name CONTAINS '感冒'
```
- 在图中查找所有标签为`Disease`的节点
- 筛选出名称中包含"感冒"的疾病（如"普通感冒"、"流行性感冒"等）

### 2. 查找推荐药物
```cypher
OPTIONAL MATCH (d)-[:recommand_drug]->(drug:Drug)
```
- 使用`OPTIONAL MATCH`查找每种疾病推荐的药物
- 沿着`recommand_drug`关系找到`Drug`节点
- `OPTIONAL`表示即使没有相关药物，疾病信息也会被返回

### 3. 查找所属科室
```cypher
OPTIONAL MATCH (d)-[:belongs_to]->(dept:Department)
```
- 同样使用`OPTIONAL MATCH`查找疾病所属的科室
- 沿着`belongs_to`关系找到`Department`节点

### 4. 返回结果
查询返回一个包含以下字段的表格：

| 字段名 | 说明 |
|--------|------|
| `disease_name` | 疾病名称 |
| `description` | 疾病描述 |
| `prevention` | 预防措施 |
| `cause` | 病因 |
| `susceptible_population` | 易感人群 |
| `treatment_method` | 治疗方法 |
| `recommended_department` | 推荐科室 |
| `treatment_duration` | 治疗周期 |
| `cure_probability` | 治愈概率 |
| `recommended_drugs` | 推荐药物列表（使用`COLLECT`聚合） |
| `departments` | 所属科室列表（使用`COLLECT`聚合） |

## 关键特点：
- **`WITH d`**：将疾病节点传递给后续查询
- **`OPTIONAL MATCH`**：即使没有匹配的关系，也会返回疾病信息
- **`COLLECT(DISTINCT ...)`**：将多个匹配结果聚合成列表，并去重
- **`AS`**：为字段设置易读的别名

## 实际应用场景：
这个查询可以用于医疗咨询系统，当用户查询"感冒"时，系统可以返回：
- 各种感冒疾病的详细信息
- 每种感冒对应的推荐药物
- 应该去哪个科室就诊

查询结果是结构化的医疗信息，便于前端展示或进一步处理。
2025-12-02 16:22:06,430 - __main__ - WARNING - 查询验证发现错误: ['使用了不存在的节点标签: d', '使用了不存在的节点标签: d']
2025-12-02 16:25:27,036 - __main__ - INFO - Neo4j 连接已关闭
2025-12-02 16:25:31,916 - __main__ - INFO - 成功连接到 Neo4j: bolt://localhost:7687
2025-12-02 16:25:49,857 - __main__ - INFO - 收到生成查询请求: 嗓子疼，感觉感觉自己好像是感冒了，应该吃什么，去那个科室看看医生？
2025-12-02 16:25:50,256 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 16:25:57,132 - __main__ - INFO - 生成的 Cypher 查询: MATCH (d:Disease)
WHERE d.name CONTAINS '感冒'
WITH d
OPTIONAL MATCH (d)-[:recommand_eat]->(food:Food)
WITH d, COLLECT(food.name) AS recommended_foods
OPTIONAL MATCH (d)-[:belongs_to]->(dept:Department)
WITH d, recommended_foods, COLLECT(dept.name) AS departments
RETURN d.name AS disease_name, 
       recommended_foods, 
       departments
2025-12-02 16:25:57,181 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 16:26:19,027 - __main__ - INFO - 查询解释: 这个Cypher查询用于从Neo4j图数据库中查找与"感冒"相关的疾病信息，并获取相关的推荐食物和所属科室。让我逐步解释：

## 查询的主要目的：
查找名称中包含"感冒"的疾病，并获取每种疾病的：
1. 疾病名称
2. 推荐的食品列表
3. 所属的科室列表

## 查询步骤分解：

### 1. 查找疾病节点
```cypher
MATCH (d:Disease)
WHERE d.name CONTAINS '感冒'
```
- 查找所有标签为"Disease"的节点
- 筛选出名称中包含"感冒"的疾病（如"普通感冒"、"流行性感冒"等）

### 2. 获取推荐食物
```cypher
OPTIONAL MATCH (d)-[:recommand_eat]->(food:Food)
WITH d, COLLECT(food.name) AS recommended_foods
```
- 使用`OPTIONAL MATCH`查找每种疾病推荐的食物
- `COLLECT()`函数将所有找到的食物名称收集到一个列表中
- 即使没有推荐食物，查询也会继续执行（`OPTIONAL`的作用）

### 3. 获取所属科室
```cypher
OPTIONAL MATCH (d)-[:belongs_to]->(dept:Department)
WITH d, recommended_foods, COLLECT(dept.name) AS departments
```
- 查找每种疾病所属的科室
- 同样使用`COLLECT()`将科室名称收集到列表中

### 4. 返回结果
```cypher
RETURN d.name AS disease_name, 
       recommended_foods, 
       departments
```
- 返回疾病名称、推荐食物列表和科室列表

## 查询特点：
- **`OPTIONAL MATCH`**：即使某些关系不存在，查询也不会失败，对应的列表会是空列表`[]`
- **`COLLECT()`**：将多个值聚合为列表
- **`WITH`子句**：用于在查询步骤之间传递数据

## 示例返回结果：
```json
{
  "disease_name": "流行性感冒",
  "recommended_foods": ["姜茶", "鸡汤", "蜂蜜柠檬水"],
  "departments": ["呼吸内科", "感染科"]
}
```

这个查询非常适合用于构建医疗知识图谱的查询功能，比如在医疗咨询系统中为用户提供疾病相关的饮食建议和就诊科室信息。
2025-12-02 16:26:19,031 - __main__ - INFO - 查询验证通过
2025-12-02 16:26:19,043 - __main__ - INFO - 收到验证查询请求: MATCH (d:Disease)
WHERE d.name CONTAINS '感冒'
WITH d
OPTIONAL MATCH (d)-[:recommand_eat]->(food:Food)
WITH d, COLLECT(food.name) AS recommended_foods
OPTIONAL MATCH (d)-[:belongs_to]->(dept:Department)
WITH d, recommended_foods, COLLECT(dept.name) AS departments
RETURN d.name AS disease_name, 
       recommended_foods, 
       departments
2025-12-02 16:26:19,043 - __main__ - INFO - 查询验证通过
2025-12-02 16:26:19,047 - __main__ - INFO - 收到执行查询请求: MATCH (d:Disease)
WHERE d.name CONTAINS '感冒'
WITH d
OPTIONAL MATCH (d)-[:recommand_eat]->(food:Food)
WITH d, COLLECT(food.name) AS recommended_foods
OPTIONAL MATCH (d)-[:belongs_to]->(dept:Department)
WITH d, recommended_foods, COLLECT(dept.name) AS departments
RETURN d.name AS disease_name, 
       recommended_foods, 
       departments
2025-12-02 16:26:19,047 - __main__ - INFO - 执行 Cypher 查询: MATCH (d:Disease)
WHERE d.name CONTAINS '感冒'
WITH d
OPTIONAL MATCH (d)-[:recommand_eat]->(food:Food)
WITH d, COLLECT(food.name) AS recommended_foods
OPTIONAL MATCH (d)-[:belongs_to]->(dept:Department)
WITH d, recommended_foods, COLLECT(dept.name) AS departments
RETURN d.name AS disease_name, 
       recommended_foods, 
       departments
2025-12-02 16:26:19,190 - __main__ - INFO - 查询执行成功，耗时: 0.142秒，返回 4 条记录
2025-12-02 16:26:19,190 - __main__ - INFO - 查询结果: [{'disease_name': '感冒', 'recommended_foods': ['凉拌香椿', '姜丝萝卜汤', '醋熘土豆丝', '绿豆薏米饭', '葱蒜粥', '薏米莲子粥', '赤小豆粥', '香椿芽粥'], 'departments': ['呼吸内科']}, {'disease_name': '流行性感冒', 'recommended_foods': ['苹果', '草莓果汁', '苹果粥', '荞麦面条', '苹果汁', '赤小豆粥', '荞麦粥', '姜糖饮'], 'departments': ['呼吸内科']}, {'disease_name': '小儿流行性感冒', 'recommended_foods': ['小白菜馅包子', '白菜包子', '酱白菜', '五丝白菜卷', '番茄鸡蛋煎饼', '大白菜饺', '酱辣白菜头', '培根白菜粥'], 'departments': ['小儿内科']}, {'disease_name': '小儿感冒', 'recommended_foods': ['酸甜白菜', '芦笋汁', '草莓果汁', '白菜粥', '芦笋粥', '百合炒芦笋', '清汤白菜卷', '凉拌香椿'], 'departments': ['小儿内科']}]
2025-12-02 16:26:19,191 - __main__ - INFO - 查询执行完成，返回 4 条记录
2025-12-02 16:38:16,626 - __main__ - INFO - 收到生成查询请求: 高血压患者饮食要注意什么？
2025-12-02 16:38:17,224 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 16:38:20,122 - __main__ - INFO - 生成的 Cypher 查询: MATCH (p:Disease)-[r:not_eat]-(f:Food) 
WHERE p.name='高血压' 
RETURN f.name
2025-12-02 16:38:20,179 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 16:38:30,875 - __main__ - INFO - 查询解释: 这个Cypher查询是用来查找高血压患者不应该吃的食物。让我一步步解释：

**查询结构：**
1. **MATCH (p:Disease)-[r:not_eat]-(f:Food)**
   - 在图中查找所有疾病节点（标签为"Disease"）和食物节点（标签为"Food"）之间的关系
   - 关系类型是"not_eat"（不应该吃）
   - `p`代表疾病节点，`f`代表食物节点，`r`代表它们之间的关系

2. **WHERE p.name='高血压'**
   - 筛选条件：只选择疾病名称为"高血压"的节点

3. **RETURN f.name**
   - 返回结果：只返回食物的名称

**简单来说：**
这个查询的意思是："找出所有高血压患者不应该吃的食物名称"

**查询结果：**
会返回一个食物名称的列表，这些食物都是高血压患者应该避免食用的。

**实际应用场景：**
这种查询在医疗健康、营养建议等系统中很有用，可以帮助高血压患者了解饮食禁忌。
2025-12-02 16:38:30,877 - __main__ - INFO - 查询验证通过
2025-12-02 16:38:30,888 - __main__ - INFO - 收到验证查询请求: MATCH (p:Disease)-[r:not_eat]-(f:Food) 
WHERE p.name='高血压' 
RETURN f.name
2025-12-02 16:38:30,888 - __main__ - INFO - 查询验证通过
2025-12-02 16:38:30,894 - __main__ - INFO - 收到执行查询请求: MATCH (p:Disease)-[r:not_eat]-(f:Food) 
WHERE p.name='高血压' 
RETURN f.name
2025-12-02 16:38:30,894 - __main__ - INFO - 执行 Cypher 查询: MATCH (p:Disease)-[r:not_eat]-(f:Food) 
WHERE p.name='高血压' 
RETURN f.name
2025-12-02 16:38:30,924 - __main__ - INFO - 查询执行成功，耗时: 0.030秒，返回 4 条记录
2025-12-02 16:38:30,925 - __main__ - INFO - 查询结果: [{'f.name': '杏仁'}, {'f.name': '咸鸭蛋'}, {'f.name': '腐竹'}, {'f.name': '鸡肝'}]
2025-12-02 16:38:30,925 - __main__ - INFO - 查询执行完成，返回 4 条记录
2025-12-02 16:40:09,106 - __main__ - INFO - 收到生成查询请求: 感冒了，嗓子很疼我想先吃点药缓解一下，然后去哪个科室看看治疗一下
2025-12-02 16:40:09,201 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 16:40:14,420 - __main__ - INFO - 生成的 Cypher 查询: MATCH (p:Disease {name: '感冒'})
OPTIONAL MATCH (p)-[:command_drug]->(d:Drug)
OPTIONAL MATCH (p)-[:belongs_to]->(dept:Department)
RETURN d.name AS 常用药品, dept.name AS 就诊科室
2025-12-02 16:40:14,462 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 16:40:33,761 - __main__ - INFO - 查询解释: 这个Cypher查询用于从Neo4j图数据库中查找与"感冒"相关的医疗信息。让我一步步解释：

## 查询目的
查找"感冒"这种疾病的常用药品和就诊科室信息。

## 查询分解

1. **`MATCH (p:Disease {name: '感冒'})`**
   - 找到标签为"Disease"（疾病）的节点
   - 且该节点的name属性值为"感冒"
   - 将这个节点赋值给变量`p`

2. **`OPTIONAL MATCH (p)-[:command_drug]->(d:Drug)`**
   - 从疾病节点`p`出发，沿着`command_drug`关系（表示"常用药品"）
   - 找到连接的标签为"Drug"（药品）的节点
   - 因为是`OPTIONAL MATCH`，即使没有相关药品，查询也会继续执行

3. **`OPTIONAL MATCH (p)-[:belongs_to]->(dept:Department)`**
   - 从疾病节点`p`出发，沿着`belongs_to`关系（表示"属于"）
   - 找到连接的标签为"Department"（科室）的节点
   - 同样是`OPTIONAL MATCH`，没有相关科室也不会中断查询

4. **`RETURN d.name AS 常用药品, dept.name AS 就诊科室`**
   - 返回药品的名称（作为"常用药品"）
   - 返回科室的名称（作为"就诊科室"）

## 查询特点
- 使用`OPTIONAL MATCH`确保即使某些信息缺失，也能返回部分结果
- 返回的结果可能包含：
  - 药品和科室都有
  - 只有药品或只有科室
  - 两者都没有（返回null值）

## 示例结果
可能的返回结果：
```
常用药品     | 就诊科室
------------|-----------
"感冒灵"    | "呼吸内科"
"板蓝根"    | "内科"
null        | "全科"
```

这个查询很适合医疗知识图谱的应用场景，帮助用户了解某种疾病的治疗信息和就诊建议。
2025-12-02 16:40:33,761 - __main__ - INFO - 查询验证通过
2025-12-02 16:40:33,772 - __main__ - INFO - 收到验证查询请求: MATCH (p:Disease {name: '感冒'})
OPTIONAL MATCH (p)-[:command_drug]->(d:Drug)
OPTIONAL MATCH (p)-[:belongs_to]->(dept:Department)
RETURN d.name AS 常用药品, dept.name AS 就诊科室
2025-12-02 16:40:33,772 - __main__ - INFO - 查询验证通过
2025-12-02 16:40:33,780 - __main__ - INFO - 收到执行查询请求: MATCH (p:Disease {name: '感冒'})
OPTIONAL MATCH (p)-[:command_drug]->(d:Drug)
OPTIONAL MATCH (p)-[:belongs_to]->(dept:Department)
RETURN d.name AS 常用药品, dept.name AS 就诊科室
2025-12-02 16:40:33,780 - __main__ - INFO - 执行 Cypher 查询: MATCH (p:Disease {name: '感冒'})
OPTIONAL MATCH (p)-[:command_drug]->(d:Drug)
OPTIONAL MATCH (p)-[:belongs_to]->(dept:Department)
RETURN d.name AS 常用药品, dept.name AS 就诊科室
2025-12-02 16:40:33,876 - __main__ - INFO - 查询执行成功，耗时: 0.096秒，返回 2 条记录
2025-12-02 16:40:33,876 - __main__ - INFO - 查询结果: [{'常用药品': '感冒灵颗粒', '就诊科室': '呼吸内科'}, {'常用药品': '利巴韦林颗粒', '就诊科室': '呼吸内科'}]
2025-12-02 16:40:33,877 - __main__ - INFO - 查询执行完成，返回 2 条记录
2025-12-02 17:14:48,296 - services.graph_service - INFO - 成功连接到 Neo4j: neo4j://0.0.0.0:7687
2025-12-02 17:24:54,501 - services.graph_service - INFO - Neo4j 连接已关闭
2025-12-02 17:31:39,298 - services.graph_service - INFO - 成功连接到 Neo4j: neo4j://0.0.0.0:7687
2025-12-02 17:36:38,374 - services.graph_service - INFO - 成功连接到 Neo4j: neo4j://0.0.0.0:7687
2025-12-02 17:40:24,765 - services.graph_service - INFO - 收到生成查询请求: 高血压患者饮食要注意什么？
2025-12-02 17:40:25,228 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 17:40:27,152 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (d:Disease)-[:not_eat]->(f:Food) 
WHERE d.name = '高血压' 
RETURN f.name
2025-12-02 17:40:27,189 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 17:40:36,981 - services.graph_service - INFO - 查询解释: 这个Cypher查询是用来查找高血压患者不应该吃的食物。让我一步步解释：

**查询结构：**
1. **`MATCH (d:Disease)-[:not_eat]->(f:Food)`**
   - 在图中查找模式：一个疾病节点（标签为Disease）通过"not_eat"关系指向一个食物节点（标签为Food）
   - `d` 代表疾病节点变量
   - `f` 代表食物节点变量
   - `:not_eat` 表示"不应该吃"的关系

2. **`WHERE d.name = '高血压'`**
   - 筛选条件：只选择疾病名称为"高血压"的节点

3. **`RETURN f.name`**
   - 返回结果：只返回食物的名称

**简单来说：**
这个查询的意思是："找出所有高血压患者不应该吃的食物名称"

**实际应用场景：**
假设你有一个医疗知识图谱，其中记录了各种疾病和饮食禁忌，这个查询可以帮助高血压患者了解他们应该避免哪些食物。

**返回结果示例：**
可能会返回类似这样的食物列表：
- 高盐食品
- 腌制食品
- 动物内脏
- 酒精饮料
- 等等
2025-12-02 17:40:36,983 - services.graph_service - INFO - 查询验证通过
2025-12-02 17:40:36,998 - services.graph_service - INFO - 收到验证查询请求: MATCH (d:Disease)-[:not_eat]->(f:Food) 
WHERE d.name = '高血压' 
RETURN f.name
2025-12-02 17:40:36,999 - services.graph_service - INFO - 查询验证通过
2025-12-02 17:40:37,004 - services.graph_service - INFO - 收到执行查询请求: MATCH (d:Disease)-[:not_eat]->(f:Food) 
WHERE d.name = '高血压' 
RETURN f.name
2025-12-02 17:40:37,004 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (d:Disease)-[:not_eat]->(f:Food) 
WHERE d.name = '高血压' 
RETURN f.name
2025-12-02 17:40:37,092 - services.graph_service - INFO - 查询执行成功，耗时: 0.088秒，返回 4 条记录
2025-12-02 17:40:37,092 - services.graph_service - INFO - 查询执行完成，返回 4 条记录
2025-12-02 17:41:30,033 - services.graph_service - INFO - 收到生成查询请求: 平日里蜂蜜加白醋一起喝有什么疗效？
2025-12-02 17:41:30,147 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 17:41:36,581 - services.graph_service - INFO - 生成的 Cypher 查询: 根据您的查询，您想了解蜂蜜加白醋一起喝的疗效。然而，我们的知识图谱主要关注疾病、症状、药物、食物等实体及其关系，并不直接包含“蜂蜜加白醋”这种特定组合的疗效信息。
为了提供相关帮助，我可以为您查找与“蜂蜜”或“醋”相关的食物信息，或者查找可能推荐食用这些食物的疾病。例如，我可以查询哪些疾病推荐食用蜂蜜或醋。
如果您想了解蜂蜜或醋作为食物在疾病治疗或饮食建议中的作用，请告诉我，我可以生成相应的查询。
例如：
- “查找推荐食用蜂蜜的疾病有哪些？”
- “查找推荐食用醋的疾病有哪些？”
请提供更具体的查询方向，以便我生成准确的Cypher查询。
2025-12-02 17:41:36,625 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 17:42:13,288 - services.graph_service - INFO - 查询解释: 您好！我理解您想了解“蜂蜜加白醋”这个特定组合的疗效，但需要向您说明的是，**标准的知识图谱（包括医疗健康类）通常不直接存储“A食物+B食物”这种具体组合的疗效信息**。

这主要是因为：
1.  **数据粒度不同**：知识图谱通常存储的是**实体（如“蜂蜜”、“醋”）** 和它们**已知的、经过验证的通用属性或关系**（如“蜂蜜-富含->维生素”、“醋-有助于缓解->咽喉不适”）。将两种食物混合后的“新配方”视为一个独立实体并存储其疗效，在数据层面非常复杂且难以验证。
2.  **避免医疗建议风险**：知识图谱的设计倾向于提供基于实体的客观信息，而非具体的、未经普遍医学认可的混合饮食处方，以避免给出可能因人而异的健康建议。

不过，您的问题完全可以通过另一种更科学、更可靠的方式来探索。我们可以利用知识图谱来**分别查找“蜂蜜”和“醋（或白醋）”各自与哪些疾病或健康益处相关**，然后您可以综合这些信息来理解它们组合可能带来的潜在效果。

以下是两种符合知识图谱结构的查询思路及对应的Cypher查询解释：

### 思路一：查找推荐食用蜂蜜或醋的疾病
这个查询旨在找出知识图谱中，哪些疾病节点与“蜂蜜”或“醋”存在“推荐食用”或“有益于”之类的关系。

**Cypher查询示例：**
```cypher
MATCH (d:Disease)-[:RECOMMENDED_FOOD|BENEFITS_FROM]->(f:Food)
WHERE f.name IN ['蜂蜜', '醋']
RETURN d.name AS 疾病名称, f.name AS 推荐食物
```
**解释（用简单的话说）：**
1.  `MATCH`： 表示我们要在图中寻找一种模式。
2.  `(d:Disease)`： 找到一个标签为 `Disease`（疾病）的节点，并给它起个临时代号叫 `d`。
3.  `-[:RECOMMENDED_FOOD|BENEFITS_FROM]->`： 寻找从疾病 `d` 指向食物节点、关系类型为 `RECOMMENDED_FOOD`（推荐食物）**或** `BENEFITS_FROM`（从中获益）的关系。`|` 符号表示“或”。
4.  `(f:Food)`： 找到关系的另一端，即标签为 `Food`（食物）的节点，代号为 `f`。
5.  `WHERE`： 添加一个条件，只选择我们感兴趣的食物。
6.  `f.name IN ['蜂蜜', '醋']`： 条件就是：食物 `f` 的名字必须是“蜂蜜”或“醋”中的一个。
7.  `RETURN`： 把找到的结果返回给我们看。
8.  `d.name AS 疾病名称, f.name AS 推荐食物`： 返回两列信息：疾病的名字和对应的推荐食物名字。

**这个查询能告诉您什么？**
它会返回一个列表，显示在知识图谱里，哪些疾病被记录为推荐食用蜂蜜或醋。例如，结果可能显示“咽喉炎”推荐食用“蜂蜜”，“高血压”推荐食用“醋”。

### 思路二：查找蜂蜜或醋的营养成分或已知功效
这个查询旨在了解“蜂蜜”和“醋”本身具有哪些属性，这些属性可能关联到某些健康效果。

**Cypher查询示例：**
```cypher
MATCH (f:Food {name: '蜂蜜'})-[r:HAS_PROPERTY|RELATED_TO]->(p:Property|Effect)
RETURN f.name AS 食物, type(r) AS 关系类型, p.name AS 属性或功效

UNION ALL

MATCH (f:Food {name: '醋'})-[r:HAS_PROPERTY|RELATED_TO]->(p:Property|Effect)
RETURN f.name AS 食物, type(r) AS 关系类型, p.name AS 属性或功效
```
**解释（用简单的话说）：**
1.  这个查询由两部分组成，用 `UNION ALL` 连接，意思是把两个查询结果合并在一起显示。
2.  **第一部分（针对蜂蜜）：**
    *   `MATCH (f:Food {name: '蜂蜜'})`： 精确找到名字叫“蜂蜜”的食物节点。
    *   `-[r:HAS_PROPERTY|RELATED_TO]->`： 寻找从“蜂蜜”节点出发，类型为 `HAS_PROPERTY`（具有属性）**或** `RELATED_TO`（相关于）的关系。
    *   `(p:Property|Effect)`： 找到关系的目标节点，其标签是 `Property`（属性，如
2025-12-02 17:42:13,291 - services.graph_service - INFO - 查询验证通过
2025-12-02 17:42:13,293 - services.graph_service - INFO - 收到生成查询请求: 平日里蜂蜜加白醋一起喝有什么疗效？
2025-12-02 17:42:13,346 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 17:42:26,133 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (f:Food)-[r:recommand_eat]-(d:Disease) 
WHERE f.name = '蜂蜜' 
RETURN d.name
2025-12-02 17:42:26,193 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 17:42:37,699 - services.graph_service - INFO - 查询解释: 这个Cypher查询的作用是：**查找与"蜂蜜"相关的疾病信息**。

让我详细解释一下：

## 查询结构解析：

1. **`MATCH (f:Food)-[r:recommand_eat]-(d:Disease)`**
   - 匹配一个模式：一个Food节点（食物）通过"recommand_eat"关系连接到一个Disease节点（疾病）
   - `f:Food`：给食物节点起别名"f"，标签是"Food"
   - `d:Disease`：给疾病节点起别名"d"，标签是"Disease"
   - `r:recommand_eat`：关系类型是"recommand_eat"（推荐食用）

2. **`WHERE f.name = '蜂蜜'`**
   - 筛选条件：只找名字为"蜂蜜"的食物节点

3. **`RETURN d.name`**
   - 返回结果：只返回疾病节点的名称

## 实际含义：
这个查询的意思是：**找出所有推荐食用"蜂蜜"的疾病**。

## 可能的场景：
假设这是一个医疗健康知识图谱，其中：
- "蜂蜜"是一个食物节点
- 某些疾病节点通过"recommand_eat"关系连接到蜂蜜
- 这个关系可能表示"患有这种疾病的患者推荐食用蜂蜜"

## 查询结果：
会返回一个疾病名称的列表，这些疾病都推荐患者食用蜂蜜。

**简单来说**：这个查询回答的问题是："哪些疾病推荐食用蜂蜜？"
2025-12-02 17:42:37,700 - services.graph_service - INFO - 查询验证通过
2025-12-02 17:42:57,262 - services.graph_service - INFO - 收到生成查询请求: 感冒了有什么症状？
2025-12-02 17:42:57,361 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 17:42:59,631 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (d:Disease)-[:has_symptom]->(s:Symptom) 
WHERE d.name = '感冒' 
RETURN s.name
2025-12-02 17:42:59,718 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 17:43:10,167 - services.graph_service - INFO - 查询解释: 这个Cypher查询是用来从Neo4j图数据库中查找与"感冒"相关的症状信息。

让我用简单的语言解释一下：

**这个查询做了三件事：**

1. **匹配模式**：`MATCH (d:Disease)-[:has_symptom]->(s:Symptom)`
   - 查找所有"疾病"节点（标记为Disease）和"症状"节点（标记为Symptom）
   - 这些节点之间通过"has_symptom"关系连接（表示疾病有这些症状）

2. **筛选条件**：`WHERE d.name = '感冒'`
   - 只选择疾病名称为"感冒"的那个疾病节点

3. **返回结果**：`RETURN s.name`
   - 返回所有与感冒相关的症状的名称

**简单来说**：这个查询相当于问数据库："感冒有哪些症状？"

**查询结果会是**：一个症状名称的列表，比如可能返回：
- "发烧"
- "咳嗽"  
- "流鼻涕"
- "喉咙痛"
- 等等

这种查询在医疗知识图谱、症状自查系统等应用中很常见，可以帮助用户了解特定疾病的典型症状。
2025-12-02 17:43:10,168 - services.graph_service - INFO - 查询验证通过
2025-12-02 17:43:10,177 - services.graph_service - INFO - 收到验证查询请求: MATCH (d:Disease)-[:has_symptom]->(s:Symptom) 
WHERE d.name = '感冒' 
RETURN s.name
2025-12-02 17:43:10,178 - services.graph_service - INFO - 查询验证通过
2025-12-02 17:43:10,187 - services.graph_service - INFO - 收到执行查询请求: MATCH (d:Disease)-[:has_symptom]->(s:Symptom) 
WHERE d.name = '感冒' 
RETURN s.name
2025-12-02 17:43:10,188 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (d:Disease)-[:has_symptom]->(s:Symptom) 
WHERE d.name = '感冒' 
RETURN s.name
2025-12-02 17:43:10,241 - services.graph_service - INFO - 查询执行成功，耗时: 0.053秒，返回 9 条记录
2025-12-02 17:43:10,241 - services.graph_service - INFO - 查询执行完成，返回 9 条记录
2025-12-02 17:45:15,754 - services.graph_service - INFO - 成功连接到 Neo4j: neo4j://0.0.0.0:7687
2025-12-02 17:45:15,756 - services.graph_service - INFO - Neo4j 连接已关闭
2025-12-02 17:46:58,254 - services.graph_service - INFO - Neo4j 连接已关闭
2025-12-02 17:51:05,346 - services.graph_service - INFO - 成功连接到 Neo4j: neo4j://0.0.0.0:7687
2025-12-02 17:52:03,660 - services.graph_service - INFO - 收到生成查询请求: 小儿麻痹症有什么症状，吃什么治疗
2025-12-02 17:52:04,047 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 17:52:11,623 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (d:Disease)-[:has_symptom]->(s:Symptom)
WHERE d.name = '小儿麻痹症'
RETURN s.name AS symptom_name
MATCH (d:Disease)-[:recommand_drug]->(dr:Drug)
WHERE d.name = '小儿麻痹症'
RETURN dr.name AS drug_name
2025-12-02 17:52:11,677 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 17:52:25,606 - services.graph_service - INFO - 查询解释: 这个Cypher查询实际上包含两个独立的查询，它们都针对名为"小儿麻痹症"的疾病进行查询。让我分别解释：

## 第一个查询部分：
```cypher
MATCH (d:Disease)-[:has_symptom]->(s:Symptom)
WHERE d.name = '小儿麻痹症'
RETURN s.name AS symptom_name
```

**解释：**
- 在知识图谱中查找标签为"Disease"的节点（用`d`表示）
- 这些疾病节点通过`has_symptom`关系连接到标签为"Symptom"的节点（用`s`表示）
- 筛选出疾病名称为"小儿麻痹症"的节点
- 返回该疾病的所有症状名称

**简单说：** 查找"小儿麻痹症"的所有症状

## 第二个查询部分：
```cypher
MATCH (d:Disease)-[:recommand_drug]->(dr:Drug)
WHERE d.name = '小儿麻痹症'
RETURN dr.name AS drug_name
```

**解释：**
- 在知识图谱中查找标签为"Disease"的节点（用`d`表示）
- 这些疾病节点通过`recommand_drug`关系连接到标签为"Drug"的节点（用`dr`表示）
- 筛选出疾病名称为"小儿麻痹症"的节点
- 返回该疾病推荐的所有药物名称

**简单说：** 查找"小儿麻痹症"的推荐药物

## 整体作用：
这两个查询分别获取：
1. "小儿麻痹症"的症状列表
2. "小儿麻痹症"的推荐药物列表

**注意：** 在实际使用中，这两个查询通常是分开执行的，或者可以用`UNION`合并结果。它们查询的是同一个疾病的不同关联信息（症状和药物）。
2025-12-02 17:52:25,607 - services.graph_service - INFO - 查询验证通过
2025-12-02 17:52:25,621 - services.graph_service - INFO - 收到验证查询请求: MATCH (d:Disease)-[:has_symptom]->(s:Symptom)
WHERE d.name = '小儿麻痹症'
RETURN s.name AS symptom_name
MATCH (d:Disease)-[:recommand_drug]->(dr:Drug)
WHERE d.name = '小儿麻痹症'
RETURN dr.name AS drug_name
2025-12-02 17:52:25,621 - services.graph_service - INFO - 查询验证通过
2025-12-02 17:52:25,626 - services.graph_service - INFO - 收到执行查询请求: MATCH (d:Disease)-[:has_symptom]->(s:Symptom)
WHERE d.name = '小儿麻痹症'
RETURN s.name AS symptom_name
MATCH (d:Disease)-[:recommand_drug]->(dr:Drug)
WHERE d.name = '小儿麻痹症'
RETURN dr.name AS drug_name
2025-12-02 17:52:25,627 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (d:Disease)-[:has_symptom]->(s:Symptom)
WHERE d.name = '小儿麻痹症'
RETURN s.name AS symptom_name
MATCH (d:Disease)-[:recommand_drug]->(dr:Drug)
WHERE d.name = '小儿麻痹症'
RETURN dr.name AS drug_name
2025-12-02 17:52:25,674 - services.graph_service - ERROR - 查询执行失败，耗时: 0.047秒，错误: {code: Neo.ClientError.Statement.SyntaxError} {message: RETURN can only be used at the end of the query. (line 3, column 1 (offset: 69))
"RETURN s.name AS symptom_name"
 ^}
2025-12-02 18:03:16,126 - services.graph_service - INFO - 收到生成查询请求: 头痛，嗓子红肿，流鼻涕，咳嗽，我可能是什么病？
2025-12-02 18:03:16,228 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 18:03:22,330 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (d:Disease)-[:has_symptom]->(s:Symptom)
WHERE s.name IN ['头痛', '嗓子红肿', '流鼻涕', '咳嗽']
WITH d, COUNT(s) AS matched_symptoms
MATCH (d)-[:has_symptom]->(all_s:Symptom)
WITH d, matched_symptoms, COUNT(all_s) AS total_symptoms
WHERE matched_symptoms >= 2
RETURN d.name AS disease_name, 
       d.desc AS description,
       matched_symptoms AS matched_symptom_count,
       total_symptoms AS total_symptom_count,
       (toFloat(matched_symptoms) / total_symptoms) * 100 AS match_percentage
ORDER BY match_percentage DESC, matched_symptoms DESC
LIMIT 10
2025-12-02 18:03:22,377 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 18:03:44,307 - services.graph_service - INFO - 查询解释: 这个Cypher查询用于在医疗知识图谱中查找与给定症状最匹配的疾病。让我一步步解释：

## 查询目的
根据用户提供的症状列表，找出最可能的相关疾病，并按匹配度排序。

## 查询步骤分解

### 1. 初步匹配
```cypher
MATCH (d:Disease)-[:has_symptom]->(s:Symptom)
WHERE s.name IN ['头痛', '嗓子红肿', '流鼻涕', '咳嗽']
```
- 查找所有与"头痛"、"嗓子红肿"、"流鼻涕"、"咳嗽"这些症状相关的疾病
- `d:Disease` 表示疾病节点
- `s:Symptom` 表示症状节点
- `-[:has_symptom]->` 表示疾病与症状之间的关系

### 2. 统计匹配症状数
```cypher
WITH d, COUNT(s) AS matched_symptoms
```
- 对每个疾病，统计它匹配了多少个输入的症状
- `matched_symptoms` 表示匹配到的症状数量

### 3. 获取疾病所有症状
```cypher
MATCH (d)-[:has_symptom]->(all_s:Symptom)
WITH d, matched_symptoms, COUNT(all_s) AS total_symptoms
```
- 查找每个疾病的所有症状（不仅仅是输入的症状）
- `total_symptoms` 表示该疾病在知识库中定义的总症状数

### 4. 筛选条件
```cypher
WHERE matched_symptoms >= 2
```
- 只保留至少匹配到2个症状的疾病
- 这是一个阈值过滤，避免匹配度太低的疾病

### 5. 返回结果
```cypher
RETURN d.name AS disease_name, 
       d.desc AS description,
       matched_symptoms AS matched_symptom_count,
       total_symptoms AS total_symptom_count,
       (toFloat(matched_symptoms) / total_symptoms) * 100 AS match_percentage
```
- 返回疾病名称、描述
- 返回匹配的症状数量和总症状数量
- 计算匹配百分比：`(匹配症状数 ÷ 总症状数) × 100%`

### 6. 排序和限制
```cypher
ORDER BY match_percentage DESC, matched_symptoms DESC
LIMIT 10
```
- 首先按匹配百分比降序排列（百分比高的在前）
- 如果百分比相同，按匹配症状数降序排列
- 只返回前10个结果

## 实际应用场景
假设用户有头痛、咳嗽等症状，这个查询会：
1. 找出包含这些症状的疾病
2. 计算每个疾病的症状匹配度
3. 返回最可能的前10种疾病

## 输出示例
可能会返回类似这样的结果：
```
感冒 - 匹配了3/5个症状 - 匹配度60%
流感 - 匹配了2/4个症状 - 匹配度50%
咽炎 - 匹配了2/6个症状 - 匹配度33%
```

这个查询特别有用，因为它不仅考虑了绝对匹配数，还考虑了相对匹配比例，避免了症状总数多的疾病被过度推荐。
2025-12-02 18:03:44,308 - services.graph_service - INFO - 查询验证通过
2025-12-02 18:03:44,316 - services.graph_service - INFO - 收到验证查询请求: MATCH (d:Disease)-[:has_symptom]->(s:Symptom)
WHERE s.name IN ['头痛', '嗓子红肿', '流鼻涕', '咳嗽']
WITH d, COUNT(s) AS matched_symptoms
MATCH (d)-[:has_symptom]->(all_s:Symptom)
WITH d, matched_symptoms, COUNT(all_s) AS total_symptoms
WHERE matched_symptoms >= 2
RETURN d.name AS disease_name, 
       d.desc AS description,
       matched_symptoms AS matched_symptom_count,
       total_symptoms AS total_symptom_count,
       (toFloat(matched_symptoms) / total_symptoms) * 100 AS match_percentage
ORDER BY match_percentage DESC, matched_symptoms DESC
LIMIT 10
2025-12-02 18:03:44,316 - services.graph_service - INFO - 查询验证通过
2025-12-02 18:03:44,322 - services.graph_service - INFO - 收到执行查询请求: MATCH (d:Disease)-[:has_symptom]->(s:Symptom)
WHERE s.name IN ['头痛', '嗓子红肿', '流鼻涕', '咳嗽']
WITH d, COUNT(s) AS matched_symptoms
MATCH (d)-[:has_symptom]->(all_s:Symptom)
WITH d, matched_symptoms, COUNT(all_s) AS total_symptoms
WHERE matched_symptoms >= 2
RETURN d.name AS disease_name, 
       d.desc AS description,
       matched_symptoms AS matched_symptom_count,
       total_symptoms AS total_symptom_count,
       (toFloat(matched_symptoms) / total_symptoms) * 100 AS match_percentage
ORDER BY match_percentage DESC, matched_symptoms DESC
LIMIT 10
2025-12-02 18:03:44,322 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (d:Disease)-[:has_symptom]->(s:Symptom)
WHERE s.name IN ['头痛', '嗓子红肿', '流鼻涕', '咳嗽']
WITH d, COUNT(s) AS matched_symptoms
MATCH (d)-[:has_symptom]->(all_s:Symptom)
WITH d, matched_symptoms, COUNT(all_s) AS total_symptoms
WHERE matched_symptoms >= 2
RETURN d.name AS disease_name, 
       d.desc AS description,
       matched_symptoms AS matched_symptom_count,
       total_symptoms AS total_symptom_count,
       (toFloat(matched_symptoms) / total_symptoms) * 100 AS match_percentage
ORDER BY match_percentage DESC, matched_symptoms DESC
LIMIT 10
2025-12-02 18:03:44,516 - services.graph_service - INFO - 查询执行成功，耗时: 0.194秒，返回 2 条记录
2025-12-02 18:03:44,516 - services.graph_service - INFO - 查询执行完成，返回 2 条记录
2025-12-02 18:09:06,557 - services.graph_service - INFO - Neo4j 连接已关闭
2025-12-02 18:09:11,606 - services.graph_service - INFO - 成功连接到 Neo4j: neo4j://0.0.0.0:7687
2025-12-02 18:09:36,130 - services.graph_service - INFO - 收到生成查询请求: 高血压患者饮食要注意什么？
2025-12-02 18:09:36,509 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 18:09:39,355 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, f.name AS food_name
2025-12-02 18:09:39,424 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 18:09:51,201 - services.graph_service - INFO - 查询解释: 这个Cypher查询是用来在Neo4j图数据库中查找与"高血压"相关的食物信息的。让我一步步解释：

## 查询的作用：
查找所有与"高血压"疾病相关的食物，并显示它们之间的关系类型和食物名称。

## 各部分解释：

1. **`MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food)`**
   - 匹配疾病节点和食物节点之间的三种关系：
     - `not_eat`：不能吃的食物
     - `do_eat`：可以吃的食物  
     - `recommand_eat`：推荐吃的食物
   - `d`代表疾病节点，`f`代表食物节点，`r`代表它们之间的关系

2. **`WHERE d.name = '高血压'`**
   - 筛选条件：只查找名称为"高血压"的疾病

3. **`RETURN type(r) AS relationship_type, f.name AS food_name`**
   - 返回结果包含两列：
     - `relationship_type`：关系类型（不能吃/可以吃/推荐吃）
     - `food_name`：食物名称

## 查询结果示例：
可能会返回类似这样的结果：
```
relationship_type | food_name
-----------------|-----------
not_eat          | 咸菜
do_eat           | 苹果
recommand_eat    | 芹菜
```

## 简单来说：
这个查询就是**找出所有与高血压相关的食物，并告诉我们每种食物是高血压患者不能吃、可以吃还是推荐吃的**。
2025-12-02 18:09:51,202 - services.graph_service - INFO - 查询验证通过
2025-12-02 18:09:51,216 - services.graph_service - INFO - 收到验证查询请求: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, f.name AS food_name
2025-12-02 18:09:51,216 - services.graph_service - INFO - 查询验证通过
2025-12-02 18:09:51,222 - services.graph_service - INFO - 收到执行查询请求: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, f.name AS food_name
2025-12-02 18:09:51,222 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, f.name AS food_name
2025-12-02 18:09:51,336 - services.graph_service - INFO - 查询执行成功，耗时: 0.114秒，返回 15 条记录
2025-12-02 18:09:51,337 - services.graph_service - INFO - 查询执行完成，返回 15 条记录
2025-12-02 19:05:14,961 - services.graph_service - INFO - 收到生成查询请求: 我现在感觉头疼，嗓子红肿，那我现在是症状，我希望去哪个科室进行治疗
2025-12-02 19:05:15,056 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 19:05:24,550 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (s1:Symptom {name: '头疼'})<-[:has_symptom]-(d:Disease)-[:has_symptom]->(s2:Symptom {name: '嗓子红肿'})
MATCH (d)-[:belongs_to]->(dept:Department)
RETURN DISTINCT dept.name AS department
2025-12-02 19:05:24,587 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 19:05:38,893 - services.graph_service - INFO - 查询解释: 这个Cypher查询的目的是**找出同时包含"头疼"和"嗓子红肿"这两种症状的疾病属于哪个科室**。

让我一步步解释：

## 查询结构解析：

1. **第一个MATCH子句**：
   ```
   MATCH (s1:Symptom {name: '头疼'})<-[:has_symptom]-(d:Disease)-[:has_symptom]->(s2:Symptom {name: '嗓子红肿'})
   ```
   - 查找一个疾病节点(`d:Disease`)
   - 这个疾病同时关联到两个症状：
     - 症状1：名字为"头疼"的节点(`s1`)
     - 症状2：名字为"嗓子红肿"的节点(`s2`)
   - 关系模式：疾病`有症状`(`has_symptom`)指向这两个症状

2. **第二个MATCH子句**：
   ```
   MATCH (d)-[:belongs_to]->(dept:Department)
   ```
   - 找到上面匹配到的疾病所属的科室
   - 关系：疾病`属于`(`belongs_to`)某个科室

3. **RETURN子句**：
   ```
   RETURN DISTINCT dept.name AS department
   ```
   - 返回科室的名称
   - 使用`DISTINCT`确保结果不重复

## 通俗理解：
想象一个医疗知识图谱，这个查询相当于问：
> "如果一个病人同时有头疼和嗓子红肿的症状，他应该去哪个科室看病？"

## 实际应用场景：
- 医疗诊断辅助系统
- 症状导向的分诊系统
- 疾病与症状关联分析

## 可能的返回结果：
比如可能是"耳鼻喉科"、"内科"或"全科"等，具体取决于知识图谱中的数据。
2025-12-02 19:05:38,893 - services.graph_service - INFO - 查询验证通过
2025-12-02 19:05:38,898 - services.graph_service - INFO - 收到验证查询请求: MATCH (s1:Symptom {name: '头疼'})<-[:has_symptom]-(d:Disease)-[:has_symptom]->(s2:Symptom {name: '嗓子红肿'})
MATCH (d)-[:belongs_to]->(dept:Department)
RETURN DISTINCT dept.name AS department
2025-12-02 19:05:38,898 - services.graph_service - INFO - 查询验证通过
2025-12-02 19:05:38,902 - services.graph_service - INFO - 收到执行查询请求: MATCH (s1:Symptom {name: '头疼'})<-[:has_symptom]-(d:Disease)-[:has_symptom]->(s2:Symptom {name: '嗓子红肿'})
MATCH (d)-[:belongs_to]->(dept:Department)
RETURN DISTINCT dept.name AS department
2025-12-02 19:05:38,902 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (s1:Symptom {name: '头疼'})<-[:has_symptom]-(d:Disease)-[:has_symptom]->(s2:Symptom {name: '嗓子红肿'})
MATCH (d)-[:belongs_to]->(dept:Department)
RETURN DISTINCT dept.name AS department
2025-12-02 19:05:39,025 - services.graph_service - INFO - 查询执行成功，耗时: 0.123秒，返回 0 条记录
2025-12-02 19:05:39,025 - services.graph_service - INFO - 查询执行完成，返回 0 条记录
2025-12-02 19:06:40,246 - services.graph_service - INFO - Neo4j 连接已关闭
2025-12-02 19:08:41,955 - services.graph_service - INFO - 成功连接到 Neo4j: neo4j://0.0.0.0:7687
2025-12-02 19:09:11,381 - services.graph_service - INFO - 收到生成查询请求: 高血压患者饮食要注意什么？
2025-12-02 19:09:11,746 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 19:09:14,880 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, f.name AS food_name
ORDER BY relationship_type
2025-12-02 19:09:14,988 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 19:09:29,569 - services.graph_service - INFO - 查询解释: 这个Cypher查询是用来在Neo4j图数据库中查找与"高血压"相关的食物信息。让我一步步解释：

## 查询目的
查找所有与"高血压"疾病相关的食物，并按照它们之间的关系类型进行分类。

## 主要组成部分：

1. **MATCH子句**：
   - `(d:Disease)`：匹配标签为"Disease"的节点（疾病节点）
   - `(f:Food)`：匹配标签为"Food"的节点（食物节点）
   - `-[r:not_eat|do_eat|recommand_eat]-`：查找三种类型的关系：
     - `not_eat`：不能吃的食物
     - `do_eat`：可以吃的食物  
     - `recommand_eat`：推荐吃的食物

2. **WHERE子句**：
   - `d.name = '高血压'`：只选择疾病名称为"高血压"的节点

3. **RETURN子句**：
   - `type(r) AS relationship_type`：返回关系类型（三种中的一种）
   - `f.name AS food_name`：返回食物名称

4. **ORDER BY子句**：
   - `ORDER BY relationship_type`：按关系类型字母顺序排序结果

## 查询结果示例：
```
relationship_type | food_name
-----------------|-----------
do_eat           | 苹果
do_eat           | 香蕉
not_eat          | 咸菜
not_eat          | 腊肉
recommand_eat    | 芹菜
recommand_eat    | 海带
```

## 简单来说：
这个查询就是**找出所有与高血压相关的食物，并告诉用户这些食物是"不能吃"、"可以吃"还是"推荐吃"的，最后按这三种分类排序显示**。
2025-12-02 19:09:29,572 - services.graph_service - INFO - 查询验证通过
2025-12-02 19:09:29,586 - services.graph_service - INFO - 收到验证查询请求: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, f.name AS food_name
ORDER BY relationship_type
2025-12-02 19:09:29,586 - services.graph_service - INFO - 查询验证通过
2025-12-02 19:09:29,591 - services.graph_service - INFO - 收到执行查询请求: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, f.name AS food_name
ORDER BY relationship_type
2025-12-02 19:09:29,591 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, f.name AS food_name
ORDER BY relationship_type
2025-12-02 19:09:29,658 - services.graph_service - INFO - 查询执行成功，耗时: 0.066秒，返回 15 条记录
2025-12-02 19:09:29,658 - services.graph_service - INFO - 查询执行完成，返回 15 条记录
2025-12-02 19:11:24,417 - services.graph_service - INFO - 收到生成查询请求: 我现在头疼，嗓子红肿，打喷嚏还咳嗽，可以吃什么药来缓解一下，有什么忌口的吗，我应该去那个科室进行治疗
2025-12-02 19:11:24,505 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 19:11:38,591 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (d:Disease)-[:has_symptom]->(s:Symptom)
WHERE s.name IN ['头疼', '嗓子红肿', '打喷嚏', '咳嗽']
WITH d, COUNT(DISTINCT s) AS symptomCount
WHERE symptomCount >= 2
MATCH (d)-[:recommand_drug]->(drug:Drug)
OPTIONAL MATCH (d)-[:not_eat]->(avoidFood:Food)
OPTIONAL MATCH (d)-[:belongs_to]->(dept:Department)
RETURN DISTINCT d.name AS disease,
       COLLECT(DISTINCT drug.name) AS recommended_drugs,
       COLLECT(DISTINCT avoidFood.name) AS avoid_foods,
       COLLECT(DISTINCT dept.name) AS departments
ORDER BY symptomCount DESC
LIMIT 5
2025-12-02 19:11:38,642 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 19:12:00,915 - services.graph_service - INFO - 查询解释: 这个Cypher查询用于从医疗知识图谱中查找疾病信息。让我一步步解释：

## 查询目的
根据一组症状，找出可能相关的疾病，并获取这些疾病的治疗药物、饮食禁忌和所属科室信息。

## 查询步骤分解：

1. **匹配疾病和症状关系**
   ```
   MATCH (d:Disease)-[:has_symptom]->(s:Symptom)
   WHERE s.name IN ['头疼', '嗓子红肿', '打喷嚏', '咳嗽']
   ```
   - 查找所有具有"头疼"、"嗓子红肿"、"打喷嚏"或"咳嗽"这些症状的疾病

2. **统计症状匹配数量**
   ```
   WITH d, COUNT(DISTINCT s) AS symptomCount
   WHERE symptomCount >= 2
   ```
   - 对每个疾病，统计它有多少个查询中提到的症状
   - 只保留至少有2个匹配症状的疾病（排除只有1个症状匹配的情况）

3. **获取相关药物**
   ```
   MATCH (d)-[:recommand_drug]->(drug:Drug)
   ```
   - 为筛选出的疾病查找推荐的治疗药物

4. **获取可选信息**
   ```
   OPTIONAL MATCH (d)-[:not_eat]->(avoidFood:Food)
   OPTIONAL MATCH (d)-[:belongs_to]->(dept:Department)
   ```
   - 查找疾病的饮食禁忌（可选，可能没有）
   - 查找疾病所属的科室（可选，可能没有）

5. **返回结果**
   ```
   RETURN DISTINCT d.name AS disease,
          COLLECT(DISTINCT drug.name) AS recommended_drugs,
          COLLECT(DISTINCT avoidFood.name) AS avoid_foods,
          COLLECT(DISTINCT dept.name) AS departments
   ORDER BY symptomCount DESC
   LIMIT 5
   ```
   - 返回疾病名称
   - 将药物名称收集为列表
   - 将禁忌食物名称收集为列表
   - 将科室名称收集为列表
   - 按匹配症状数量降序排列（症状匹配越多，排名越靠前）
   - 只返回前5个结果

## 实际应用场景
比如用户输入了"头疼、咳嗽"等症状，这个查询会：
1. 找出所有包含这些症状的疾病
2. 排除只匹配1个症状的疾病（提高准确性）
3. 为匹配的疾病提供治疗建议
4. 按匹配程度排序，给出最可能的前5种疾病

## 结果示例
可能返回类似这样的结果：
```
感冒：推荐药物[阿司匹林, 感冒灵]，禁忌食物[辛辣食物]，科室[呼吸内科]
流感：推荐药物[奥司他韦]，禁忌食物[]，科室[感染科]
...
```

这个查询在医疗诊断辅助系统中很有用，可以根据症状快速缩小疾病范围并提供治疗建议。
2025-12-02 19:12:00,916 - services.graph_service - INFO - 查询验证通过
2025-12-02 19:12:00,917 - services.graph_service - INFO - 收到生成查询请求: 我现在头疼，嗓子红肿，打喷嚏还咳嗽，可以吃什么药来缓解一下，有什么忌口的吗，我应该去那个科室进行治疗
2025-12-02 19:12:00,963 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 19:12:15,039 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (d:Disease)-[:has_symptom]->(s:Symptom)
WHERE s.name IN ['头疼', '嗓子红肿', '打喷嚏', '咳嗽']
WITH d, COUNT(DISTINCT s) AS symptomCount
WHERE symptomCount >= 2
MATCH (d)-[:recommand_drug]->(drug:Drug)
OPTIONAL MATCH (d)-[:not_eat]->(avoidFood:Food)
OPTIONAL MATCH (d)-[:belongs_to]->(dept:Department)
RETURN DISTINCT d.name AS disease,
       COLLECT(DISTINCT drug.name) AS recommended_drugs,
       COLLECT(DISTINCT avoidFood.name) AS avoid_foods,
       COLLECT(DISTINCT dept.name) AS departments
LIMIT 5
2025-12-02 19:12:15,074 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 19:12:34,206 - services.graph_service - INFO - 查询解释: 这个Cypher查询用于从医疗知识图谱中查找疾病信息。让我一步步解释：

## 查询目的
查找至少包含2个特定症状的疾病，并返回这些疾病的相关信息（推荐药物、忌食食物、所属科室）。

## 查询步骤分解：

1. **匹配疾病和症状关系**
   ```
   MATCH (d:Disease)-[:has_symptom]->(s:Symptom)
   WHERE s.name IN ['头疼', '嗓子红肿', '打喷嚏', '咳嗽']
   ```
   - 找到所有有症状的疾病
   - 只筛选出有这4种症状之一的疾病

2. **统计症状数量**
   ```
   WITH d, COUNT(DISTINCT s) AS symptomCount
   WHERE symptomCount >= 2
   ```
   - 对每个疾病，统计它有多少个不同的指定症状
   - 只保留至少有2个指定症状的疾病

3. **获取相关药物**
   ```
   MATCH (d)-[:recommand_drug]->(drug:Drug)
   ```
   - 找到这些疾病推荐的药物

4. **获取可选信息**
   ```
   OPTIONAL MATCH (d)-[:not_eat]->(avoidFood:Food)
   OPTIONAL MATCH (d)-[:belongs_to]->(dept:Department)
   ```
   - 查找疾病的忌食食物（可选，可能没有）
   - 查找疾病所属科室（可选，可能没有）

5. **返回结果**
   ```
   RETURN DISTINCT d.name AS disease,
          COLLECT(DISTINCT drug.name) AS recommended_drugs,
          COLLECT(DISTINCT avoidFood.name) AS avoid_foods,
          COLLECT(DISTINCT dept.name) AS departments
   LIMIT 5
   ```
   - 返回疾病名称
   - 将药物名称收集为列表
   - 将忌食食物名称收集为列表
   - 将科室名称收集为列表
   - 限制返回5条结果

## 简单来说
这个查询的意思是：**"找出至少有头疼、嗓子红肿、打喷嚏、咳嗽这4个症状中任意2个的疾病，并显示这些疾病的推荐药物、忌食食物和所属科室，最多返回5个结果。"**

## 实际应用场景
比如用户输入了多个症状，系统可以：
- 找到可能患有的疾病
- 提供治疗建议（药物）
- 给出饮食注意事项
- 建议应该去哪个科室就诊
2025-12-02 19:12:34,208 - services.graph_service - INFO - 查询验证通过
2025-12-02 19:13:25,759 - services.graph_service - INFO - 收到生成查询请求: 我现在头疼，嗓子红肿，打喷嚏还咳嗽，可以吃什么药来缓解一下，有什么忌口的吗
2025-12-02 19:13:25,870 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 19:13:41,387 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (d:Disease)-[:has_symptom]->(s:Symptom)
WHERE s.name IN ['头疼', '嗓子红肿', '打喷嚏', '咳嗽']
WITH d, COUNT(DISTINCT s) AS symptomCount
WHERE symptomCount >= 2
RETURN d.name AS diseaseName
LIMIT 1
2025-12-02 19:13:41,432 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 19:13:56,922 - services.graph_service - INFO - 查询解释: 这个Cypher查询是用来在Neo4j图数据库中查找疾病的。让我一步步解释：

## 查询目的
找出**至少包含2个指定症状**的疾病。

## 查询步骤分解：

1. **匹配模式**
   ```
   MATCH (d:Disease)-[:has_symptom]->(s:Symptom)
   ```
   - 查找所有疾病节点（标签为`Disease`）
   - 这些疾病通过`has_symptom`关系连接到症状节点（标签为`Symptom`）

2. **筛选症状**
   ```
   WHERE s.name IN ['头疼', '嗓子红肿', '打喷嚏', '咳嗽']
   ```
   - 只关注这4个特定症状：头疼、嗓子红肿、打喷嚏、咳嗽

3. **统计症状数量**
   ```
   WITH d, COUNT(DISTINCT s) AS symptomCount
   ```
   - 对每个疾病，计算它有多少个**不同的**指定症状
   - 比如：如果一个疾病有"头疼"和"咳嗽"两个症状，symptomCount=2

4. **筛选疾病**
   ```
   WHERE symptomCount >= 2
   ```
   - 只保留至少有2个指定症状的疾病

5. **返回结果**
   ```
   RETURN d.name AS diseaseName
   LIMIT 1
   ```
   - 返回符合条件的疾病名称
   - `LIMIT 1`表示只返回第一个匹配的结果

## 实际应用场景
假设数据库中有：
- 感冒：有头疼、打喷嚏、咳嗽
- 流感：有头疼、嗓子红肿
- 过敏：只有打喷嚏

查询结果会返回：
- 感冒（有3个症状）
- 流感（有2个症状）

但由于加了`LIMIT 1`，只会返回第一个匹配的疾病名称（比如"感冒"）。

## 简单总结
这个查询的意思是：**"给我找一个至少包含头疼、嗓子红肿、打喷嚏、咳嗽这4个症状中任意2个的疾病"**。
2025-12-02 19:13:56,925 - services.graph_service - INFO - 查询验证通过
2025-12-02 19:13:56,926 - services.graph_service - INFO - 收到生成查询请求: 我现在头疼，嗓子红肿，打喷嚏还咳嗽，可以吃什么药来缓解一下，有什么忌口的吗
2025-12-02 19:13:56,967 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 19:14:07,008 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (d:Disease)-[:has_symptom]->(s:Symptom)
WHERE s.name IN ['头疼', '嗓子红肿', '打喷嚏', '咳嗽']
WITH d, COUNT(DISTINCT s) AS symptomCount
WHERE symptomCount >= 3
MATCH (d)-[:recommand_drug]->(drug:Drug)
MATCH (d)-[:not_eat]->(avoidFood:Food)
RETURN d.name AS disease, 
       COLLECT(DISTINCT drug.name) AS recommended_drugs,
       COLLECT(DISTINCT avoidFood.name) AS avoid_foods
LIMIT 5
2025-12-02 19:14:07,057 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 19:14:25,629 - services.graph_service - INFO - 查询解释: 这个Cypher查询用于在医疗知识图谱中查找疾病信息，具体解释如下：

## 查询目的
查找**至少包含3个指定症状**的疾病，并返回这些疾病的推荐药物和忌口食物。

## 查询步骤分解

### 1. 匹配疾病和症状
```cypher
MATCH (d:Disease)-[:has_symptom]->(s:Symptom)
WHERE s.name IN ['头疼', '嗓子红肿', '打喷嚏', '咳嗽']
```
- 查找所有有症状关系的疾病节点（`d`）和症状节点（`s`）
- 只筛选出症状名称为"头疼"、"嗓子红肿"、"打喷嚏"、"咳嗽"的症状

### 2. 统计症状数量并筛选
```cypher
WITH d, COUNT(DISTINCT s) AS symptomCount
WHERE symptomCount >= 3
```
- 对每个疾病，统计它有多少个**不同的**指定症状
- 只保留至少有3个以上指定症状的疾病

### 3. 查找相关药物和食物
```cypher
MATCH (d)-[:recommand_drug]->(drug:Drug)
MATCH (d)-[:not_eat]->(avoidFood:Food)
```
- 查找这些疾病的推荐药物（通过`recommand_drug`关系）
- 查找这些疾病的忌口食物（通过`not_eat`关系）

### 4. 返回结果
```cypher
RETURN d.name AS disease, 
       COLLECT(DISTINCT drug.name) AS recommended_drugs,
       COLLECT(DISTINCT avoidFood.name) AS avoid_foods
LIMIT 5
```
- 返回疾病名称
- 将每个疾病的所有推荐药物名称收集成一个列表
- 将每个疾病的所有忌口食物名称收集成一个列表
- 最多返回5条结果

## 实际应用场景
这个查询可以用于：
- **智能诊断辅助**：用户输入多个症状，系统推荐可能的疾病
- **治疗方案查询**：找到疾病后自动获取用药建议和饮食禁忌
- **医疗知识检索**：快速查找特定症状组合的相关医疗信息

## 示例结果可能如下：
```
疾病：普通感冒
推荐药物：[阿司匹林, 感冒灵]
忌口食物：[辛辣食物, 冷饮]
```

这个查询特别适合构建症状自查系统或医生辅助诊断工具。
2025-12-02 19:14:25,630 - services.graph_service - INFO - 查询验证通过
2025-12-02 19:14:25,634 - services.graph_service - INFO - 收到验证查询请求: MATCH (d:Disease)-[:has_symptom]->(s:Symptom)
WHERE s.name IN ['头疼', '嗓子红肿', '打喷嚏', '咳嗽']
WITH d, COUNT(DISTINCT s) AS symptomCount
WHERE symptomCount >= 3
MATCH (d)-[:recommand_drug]->(drug:Drug)
MATCH (d)-[:not_eat]->(avoidFood:Food)
RETURN d.name AS disease, 
       COLLECT(DISTINCT drug.name) AS recommended_drugs,
       COLLECT(DISTINCT avoidFood.name) AS avoid_foods
LIMIT 5
2025-12-02 19:14:25,634 - services.graph_service - INFO - 查询验证通过
2025-12-02 19:14:25,636 - services.graph_service - INFO - 收到执行查询请求: MATCH (d:Disease)-[:has_symptom]->(s:Symptom)
WHERE s.name IN ['头疼', '嗓子红肿', '打喷嚏', '咳嗽']
WITH d, COUNT(DISTINCT s) AS symptomCount
WHERE symptomCount >= 3
MATCH (d)-[:recommand_drug]->(drug:Drug)
MATCH (d)-[:not_eat]->(avoidFood:Food)
RETURN d.name AS disease, 
       COLLECT(DISTINCT drug.name) AS recommended_drugs,
       COLLECT(DISTINCT avoidFood.name) AS avoid_foods
LIMIT 5
2025-12-02 19:14:25,637 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (d:Disease)-[:has_symptom]->(s:Symptom)
WHERE s.name IN ['头疼', '嗓子红肿', '打喷嚏', '咳嗽']
WITH d, COUNT(DISTINCT s) AS symptomCount
WHERE symptomCount >= 3
MATCH (d)-[:recommand_drug]->(drug:Drug)
MATCH (d)-[:not_eat]->(avoidFood:Food)
RETURN d.name AS disease, 
       COLLECT(DISTINCT drug.name) AS recommended_drugs,
       COLLECT(DISTINCT avoidFood.name) AS avoid_foods
LIMIT 5
2025-12-02 19:14:25,739 - services.graph_service - INFO - 查询执行成功，耗时: 0.102秒，返回 0 条记录
2025-12-02 19:14:25,739 - services.graph_service - INFO - 查询执行完成，返回 0 条记录
2025-12-02 19:20:33,250 - services.graph_service - INFO - 收到生成查询请求: 天天上班就想吃饭是什么病
2025-12-02 19:20:33,361 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 19:20:36,446 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (d:Disease)-[:has_symptom]->(s:Symptom) 
WHERE s.name CONTAINS '想吃饭' OR s.name CONTAINS '食欲' OR s.name CONTAINS '饥饿'
RETURN d.name, d.desc
2025-12-02 19:20:36,500 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 19:20:50,339 - services.graph_service - INFO - 查询解释: 这个Cypher查询是用来在Neo4j图数据库中查找与特定症状相关的疾病信息。让我一步步解释：

## 查询的作用：
查找所有与"食欲相关症状"有关的疾病，并返回这些疾病的基本信息。

## 具体步骤：

1. **MATCH (d:Disease)-[:has_symptom]->(s:Symptom)**
   - 匹配模式：找到所有"疾病"节点（标签为Disease）通过"has_symptom"关系连接到"症状"节点（标签为Symptom）
   - `d` 代表疾病节点
   - `s` 代表症状节点

2. **WHERE s.name CONTAINS '想吃饭' OR s.name CONTAINS '食欲' OR s.name CONTAINS '饥饿'**
   - 筛选条件：只选择症状名称中包含以下关键词之一的症状
   - "想吃饭"（可能表示食欲增加）
   - "食欲"（食欲相关）
   - "饥饿"（饥饿感）

3. **RETURN d.name, d.desc**
   - 返回结果：对于匹配到的每个疾病，返回
   - 疾病名称（d.name）
   - 疾病描述（d.desc）

## 简单来说：
这个查询的意思是："找出所有具有'想吃饭'、'食欲'或'饥饿'相关症状的疾病，并告诉我这些疾病的名字和描述。"

## 实际应用场景：
这可能在医疗知识图谱中使用，帮助医生或患者：
- 了解哪些疾病可能导致食欲变化
- 根据症状查找可能的疾病
- 建立症状与疾病的关联关系

查询结果会是一个列表，每行包含一个疾病的名称和描述，这些疾病都至少有一个与食欲相关的症状。
2025-12-02 19:20:50,340 - services.graph_service - INFO - 查询验证通过
2025-12-02 19:20:50,344 - services.graph_service - INFO - 收到验证查询请求: MATCH (d:Disease)-[:has_symptom]->(s:Symptom) 
WHERE s.name CONTAINS '想吃饭' OR s.name CONTAINS '食欲' OR s.name CONTAINS '饥饿'
RETURN d.name, d.desc
2025-12-02 19:20:50,344 - services.graph_service - INFO - 查询验证通过
2025-12-02 19:20:50,346 - services.graph_service - INFO - 收到执行查询请求: MATCH (d:Disease)-[:has_symptom]->(s:Symptom) 
WHERE s.name CONTAINS '想吃饭' OR s.name CONTAINS '食欲' OR s.name CONTAINS '饥饿'
RETURN d.name, d.desc
2025-12-02 19:20:50,346 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (d:Disease)-[:has_symptom]->(s:Symptom) 
WHERE s.name CONTAINS '想吃饭' OR s.name CONTAINS '食欲' OR s.name CONTAINS '饥饿'
RETURN d.name, d.desc
2025-12-02 19:20:50,452 - services.graph_service - INFO - 查询执行成功，耗时: 0.106秒，返回 84 条记录
2025-12-02 19:20:50,452 - services.graph_service - INFO - 查询执行完成，返回 84 条记录
2025-12-02 19:32:55,760 - services.graph_service - INFO - Neo4j 连接已关闭
2025-12-02 19:33:05,845 - services.graph_service - INFO - 成功连接到 Neo4j: neo4j://0.0.0.0:7687
2025-12-02 19:33:38,383 - services.graph_service - INFO - 收到生成查询请求: 脊髓灰质炎怎么治疗，有什么忌口吗
2025-12-02 19:33:38,772 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 19:33:43,430 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (d:Disease {name: '脊髓灰质炎'})
OPTIONAL MATCH (d)-[:recommand_drug]->(drug:Drug)
OPTIONAL MATCH (d)-[:not_eat]->(food:Food)
RETURN d.cure_way AS 治疗方法, 
       COLLECT(DISTINCT drug.name) AS 推荐药物,
       COLLECT(DISTINCT food.name) AS 忌口食物
2025-12-02 19:33:43,477 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 19:34:02,731 - services.graph_service - INFO - 查询解释: 这个Cypher查询用于从Neo4j图数据库中查找关于"脊髓灰质炎"疾病的相关信息。让我一步步解释：

## 查询结构解析：

### 1. **MATCH (d:Disease {name: '脊髓灰质炎'})**
   - 查找标签为"Disease"的节点
   - 条件是节点的"name"属性值为"脊髓灰质炎"
   - 将这个节点赋值给变量`d`

### 2. **OPTIONAL MATCH (d)-[:recommand_drug]->(drug:Drug)**
   - 可选匹配：查找从疾病节点`d`通过"recommand_drug"关系连接的Drug节点
   - 使用OPTIONAL MATCH意味着即使没有找到匹配的药物，查询也会继续执行
   - 将找到的药物节点赋值给变量`drug`

### 3. **OPTIONAL MATCH (d)-[:not_eat]->(food:Food)**
   - 可选匹配：查找从疾病节点`d`通过"not_eat"关系连接的Food节点
   - 同样使用OPTIONAL MATCH，即使没有忌口食物也会继续
   - 将找到的食物节点赋值给变量`food`

### 4. **RETURN 部分**
   - `d.cure_way AS 治疗方法`：返回疾病节点的"cure_way"属性，并重命名为"治疗方法"
   - `COLLECT(DISTINCT drug.name) AS 推荐药物`：
     - 收集所有找到的药物名称
     - DISTINCT确保没有重复
     - 结果是一个数组
   - `COLLECT(DISTINCT food.name) AS 忌口食物`：
     - 收集所有找到的食物名称
     - DISTINCT确保没有重复
     - 结果是一个数组

## 查询结果：
查询会返回一行结果，包含三个字段：
1. **治疗方法**：脊髓灰质炎的治疗方式
2. **推荐药物**：所有推荐药物的名称列表（数组形式）
3. **忌口食物**：所有需要忌口的食物名称列表（数组形式）

## 特点：
- 使用OPTIONAL MATCH确保即使某些关系不存在，查询也能返回结果
- 使用COLLECT函数将多个相关节点聚合为数组
- 查询结构清晰，易于理解疾病-药物-食物之间的关系

这个查询非常适合医疗知识图谱的应用场景，能够一次性获取疾病的治疗信息和相关注意事项。
2025-12-02 19:34:02,734 - services.graph_service - INFO - 查询验证通过
2025-12-02 19:34:02,748 - services.graph_service - INFO - 收到验证查询请求: MATCH (d:Disease {name: '脊髓灰质炎'})
OPTIONAL MATCH (d)-[:recommand_drug]->(drug:Drug)
OPTIONAL MATCH (d)-[:not_eat]->(food:Food)
RETURN d.cure_way AS 治疗方法, 
       COLLECT(DISTINCT drug.name) AS 推荐药物,
       COLLECT(DISTINCT food.name) AS 忌口食物
2025-12-02 19:34:02,748 - services.graph_service - INFO - 查询验证通过
2025-12-02 19:34:02,752 - services.graph_service - INFO - 收到执行查询请求: MATCH (d:Disease {name: '脊髓灰质炎'})
OPTIONAL MATCH (d)-[:recommand_drug]->(drug:Drug)
OPTIONAL MATCH (d)-[:not_eat]->(food:Food)
RETURN d.cure_way AS 治疗方法, 
       COLLECT(DISTINCT drug.name) AS 推荐药物,
       COLLECT(DISTINCT food.name) AS 忌口食物
2025-12-02 19:34:02,753 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (d:Disease {name: '脊髓灰质炎'})
OPTIONAL MATCH (d)-[:recommand_drug]->(drug:Drug)
OPTIONAL MATCH (d)-[:not_eat]->(food:Food)
RETURN d.cure_way AS 治疗方法, 
       COLLECT(DISTINCT drug.name) AS 推荐药物,
       COLLECT(DISTINCT food.name) AS 忌口食物
2025-12-02 19:34:02,870 - services.graph_service - INFO - 查询执行成功，耗时: 0.117秒，返回 0 条记录
2025-12-02 19:34:02,870 - services.graph_service - INFO - 查询执行完成，返回 0 条记录
2025-12-02 19:34:43,472 - services.graph_service - INFO - 收到生成查询请求: 小儿麻痹症
2025-12-02 19:34:43,552 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 19:34:46,903 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (d:Disease) 
WHERE d.name CONTAINS '小儿麻痹症' 
RETURN d.name, d.desc, d.prevent, d.cause, d.easy_get, d.cure_way, d.cure_department, d.cure_lasttime, d.cured_prob
2025-12-02 19:34:46,961 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 19:35:00,493 - services.graph_service - INFO - 查询解释: 这个Cypher查询是在Neo4j图数据库中查找与"小儿麻痹症"相关的疾病信息。让我详细解释每个部分：

## 查询结构解析：

**1. MATCH (d:Disease)**
- 在数据库中查找所有标签为"Disease"（疾病）的节点
- 给这些节点起一个别名"d"，方便后续引用

**2. WHERE d.name CONTAINS '小儿麻痹症'**
- 筛选条件：只选择疾病名称中包含"小儿麻痹症"这个关键词的节点
- `CONTAINS`是模糊匹配，不是精确匹配，所以会找到名称中有"小儿麻痹症"的所有疾病

**3. RETURN 后面的部分**
- 指定要返回的疾病信息字段：
  - `d.name`：疾病名称
  - `d.desc`：疾病描述
  - `d.prevent`：预防方法
  - `d.cause`：病因
  - `d.easy_get`：易感人群
  - `d.cure_way`：治疗方法
  - `d.cure_department`：就诊科室
  - `d.cure_lasttime`：治疗周期
  - `d.cured_prob`：治愈概率

## 简单来说：
这个查询就是**在疾病数据库中搜索名称包含"小儿麻痹症"的所有疾病，并返回这些疾病的详细信息**，包括名称、描述、预防、病因、治疗方法等9个方面的信息。

## 实际应用场景：
这类似于在一个医疗知识图谱中搜索特定疾病，获取全面的疾病知识，可用于：
- 医疗咨询系统
- 疾病知识查询
- 医疗信息检索等场景
2025-12-02 19:35:00,496 - services.graph_service - INFO - 查询验证通过
2025-12-02 19:35:00,504 - services.graph_service - INFO - 收到验证查询请求: MATCH (d:Disease) 
WHERE d.name CONTAINS '小儿麻痹症' 
RETURN d.name, d.desc, d.prevent, d.cause, d.easy_get, d.cure_way, d.cure_department, d.cure_lasttime, d.cured_prob
2025-12-02 19:35:00,504 - services.graph_service - INFO - 查询验证通过
2025-12-02 19:35:00,508 - services.graph_service - INFO - 收到执行查询请求: MATCH (d:Disease) 
WHERE d.name CONTAINS '小儿麻痹症' 
RETURN d.name, d.desc, d.prevent, d.cause, d.easy_get, d.cure_way, d.cure_department, d.cure_lasttime, d.cured_prob
2025-12-02 19:35:00,508 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (d:Disease) 
WHERE d.name CONTAINS '小儿麻痹症' 
RETURN d.name, d.desc, d.prevent, d.cause, d.easy_get, d.cure_way, d.cure_department, d.cure_lasttime, d.cured_prob
2025-12-02 19:35:00,568 - neo4j.notifications - WARNING - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownPropertyKeyWarning} {category: UNRECOGNIZED} {title: The provided property key is not in the database} {description: One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: cure_department)} {position: line: 3, column: 70, offset: 119} for query: "MATCH (d:Disease) \nWHERE d.name CONTAINS '小儿麻痹症' \nRETURN d.name, d.desc, d.prevent, d.cause, d.easy_get, d.cure_way, d.cure_department, d.cure_lasttime, d.cured_prob"
2025-12-02 19:35:00,569 - neo4j.notifications - WARNING - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownPropertyKeyWarning} {category: UNRECOGNIZED} {title: The provided property key is not in the database} {description: One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: cured_prob)} {position: line: 3, column: 106, offset: 155} for query: "MATCH (d:Disease) \nWHERE d.name CONTAINS '小儿麻痹症' \nRETURN d.name, d.desc, d.prevent, d.cause, d.easy_get, d.cure_way, d.cure_department, d.cure_lasttime, d.cured_prob"
2025-12-02 19:35:00,569 - services.graph_service - INFO - 查询执行成功，耗时: 0.061秒，返回 0 条记录
2025-12-02 19:35:00,569 - services.graph_service - INFO - 查询执行完成，返回 0 条记录
2025-12-02 19:36:43,002 - services.graph_service - INFO - 收到生成查询请求: 高血压患者饮食要注意什么？
2025-12-02 19:36:43,093 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 19:36:46,252 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (d:Disease)-[r:not_eat|:do_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS diet_type, f.name AS food_name
2025-12-02 19:36:46,298 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 19:37:00,960 - services.graph_service - INFO - 查询解释: 这个Cypher查询是用来在Neo4j图数据库中查找与"高血压"相关的饮食建议的。让我详细解释一下：

## 查询目的
查找高血压患者应该避免或推荐食用的食物。

## 查询分解

1. **`MATCH (d:Disease)-[r:not_eat|:do_eat]-(f:Food)`**
   - 匹配疾病节点和食物节点之间的关系
   - `d:Disease`：标签为"Disease"的节点（代表疾病）
   - `f:Food`：标签为"Food"的节点（代表食物）
   - `[r:not_eat|:do_eat]`：两种类型的关系：
     - `not_eat`：不应该吃（禁忌食物）
     - `do_eat`：应该吃（推荐食物）

2. **`WHERE d.name = '高血压'`**
   - 筛选条件：只查找疾病名称为"高血压"的记录

3. **`RETURN type(r) AS diet_type, f.name AS food_name`**
   - 返回结果：
     - `diet_type`：饮食类型（是"not_eat"还是"do_eat"）
     - `food_name`：食物名称

## 查询结果示例
查询结果会返回类似这样的数据：
```
diet_type | food_name
----------|----------
not_eat   | 咸菜
not_eat   | 肥肉
do_eat    | 芹菜
do_eat    | 香蕉
```

## 简单理解
这个查询相当于问："高血压患者有哪些应该避免和推荐食用的食物？"

通过这个查询，可以清楚地看到：
- 哪些食物高血压患者**不应该吃**（not_eat关系）
- 哪些食物高血压患者**应该吃**（do_eat关系）
2025-12-02 19:37:00,961 - services.graph_service - INFO - 查询验证通过
2025-12-02 19:37:00,972 - services.graph_service - INFO - 收到验证查询请求: MATCH (d:Disease)-[r:not_eat|:do_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS diet_type, f.name AS food_name
2025-12-02 19:37:00,972 - services.graph_service - INFO - 查询验证通过
2025-12-02 19:37:00,977 - services.graph_service - INFO - 收到执行查询请求: MATCH (d:Disease)-[r:not_eat|:do_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS diet_type, f.name AS food_name
2025-12-02 19:37:00,977 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (d:Disease)-[r:not_eat|:do_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS diet_type, f.name AS food_name
2025-12-02 19:37:01,015 - services.graph_service - ERROR - 查询执行失败，耗时: 0.038秒，错误: {code: Neo.ClientError.Statement.SyntaxError} {message: The semantics of using colon in the separation of alternative relationship types in conjunction with
the use of variable binding, inlined property predicates, or variable length is no longer supported.
Please separate the relationships types using `:not_eat|do_eat` instead. (line 1, column 29 (offset: 28))
"MATCH (d:Disease)-[r:not_eat|:do_eat]-(f:Food)"
                             ^}
2025-12-02 19:37:47,938 - services.graph_service - INFO - Neo4j 连接已关闭
2025-12-02 19:38:00,273 - services.graph_service - INFO - 成功连接到 Neo4j: neo4j://0.0.0.0:7687
2025-12-02 19:38:10,392 - services.graph_service - INFO - 收到生成查询请求: 高血压患者饮食要注意什么？
2025-12-02 19:38:10,789 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 19:38:13,396 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (d:Disease)-[r:not_eat|:do_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS diet_type, f.name AS food_name
2025-12-02 19:38:13,433 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 19:38:26,462 - services.graph_service - INFO - 查询解释: 这个Cypher查询是用来查找与"高血压"相关的饮食建议的。让我一步步解释：

## 查询目的
找出高血压患者**应该吃**和**不应该吃**的食物。

## 各部分解释：

1. **`MATCH (d:Disease)-[r:not_eat|:do_eat]-(f:Food)`**
   - 匹配疾病节点和食物节点之间的关系
   - `d:Disease`：标签为"Disease"的节点（代表疾病）
   - `f:Food`：标签为"Food"的节点（代表食物）
   - `[r:not_eat|:do_eat]`：两种类型的关系：
     - `:not_eat`：不应该吃的关系
     - `:do_eat`：应该吃的关系

2. **`WHERE d.name = '高血压'`**
   - 筛选条件：只找疾病名称为"高血压"的节点

3. **`RETURN type(r) AS diet_type, f.name AS food_name`**
   - 返回结果：
     - `type(r)`：关系的类型（是"not_eat"还是"do_eat"）
     - `f.name`：食物的名称

## 查询结果示例：
```
diet_type | food_name
----------|----------
do_eat    | 芹菜
do_eat    | 香蕉
not_eat   | 咸菜
not_eat   | 肥肉
```

## 简单来说：
这个查询就是**在知识图谱中查找高血压患者的饮食宜忌**，告诉你哪些食物适合吃，哪些不适合吃。
2025-12-02 19:38:26,464 - services.graph_service - INFO - 查询验证通过
2025-12-02 19:38:26,481 - services.graph_service - INFO - 收到验证查询请求: MATCH (d:Disease)-[r:not_eat|:do_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS diet_type, f.name AS food_name
2025-12-02 19:38:26,481 - services.graph_service - INFO - 查询验证通过
2025-12-02 19:38:26,486 - services.graph_service - INFO - 收到执行查询请求: MATCH (d:Disease)-[r:not_eat|:do_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS diet_type, f.name AS food_name
2025-12-02 19:38:26,486 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (d:Disease)-[r:not_eat|:do_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS diet_type, f.name AS food_name
2025-12-02 19:38:26,537 - services.graph_service - ERROR - 查询执行失败，耗时: 0.050秒，错误: {code: Neo.ClientError.Statement.SyntaxError} {message: The semantics of using colon in the separation of alternative relationship types in conjunction with
the use of variable binding, inlined property predicates, or variable length is no longer supported.
Please separate the relationships types using `:not_eat|do_eat` instead. (line 1, column 29 (offset: 28))
"MATCH (d:Disease)-[r:not_eat|:do_eat]-(f:Food)"
                             ^}
2025-12-02 19:40:26,697 - services.graph_service - INFO - Neo4j 连接已关闭
2025-12-02 19:40:31,364 - services.graph_service - INFO - 成功连接到 Neo4j: neo4j://0.0.0.0:7687
2025-12-02 19:40:37,842 - services.graph_service - INFO - 收到生成查询请求: 高血压患者饮食要注意什么？
2025-12-02 19:40:38,196 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 19:40:41,657 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, f.name AS food_name
2025-12-02 19:40:41,701 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 19:40:53,901 - services.graph_service - INFO - 查询解释: 这个Cypher查询用于在Neo4j图数据库中查找与"高血压"相关的食物信息。让我详细解释一下：

## 查询的作用：
查找所有与"高血压"疾病相关的食物，并显示它们之间的关系类型和食物名称。

## 各部分解释：

1. **`MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food)`**
   - 匹配疾病节点和食物节点之间的三种关系：
     - `not_eat`：不能吃的食物
     - `do_eat`：可以吃的食物  
     - `recommand_eat`：推荐吃的食物
   - `d`：代表疾病节点（标签为Disease）
   - `f`：代表食物节点（标签为Food）
   - `r`：代表关系变量

2. **`WHERE d.name = '高血压'`**
   - 筛选条件：只查找名称为"高血压"的疾病

3. **`RETURN type(r) AS relationship_type, f.name AS food_name`**
   - 返回结果包含两列：
     - `relationship_type`：关系类型（不能吃/可以吃/推荐吃）
     - `food_name`：食物名称

## 查询结果示例：
```
relationship_type | food_name
-----------------|-----------
not_eat          | 咸菜
do_eat           | 苹果
recommand_eat    | 芹菜
```

## 简单来说：
这个查询就是**找出高血压患者不能吃、可以吃和推荐吃的所有食物列表**。
2025-12-02 19:40:53,904 - services.graph_service - INFO - 查询验证通过
2025-12-02 19:40:53,918 - services.graph_service - INFO - 收到验证查询请求: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, f.name AS food_name
2025-12-02 19:40:53,919 - services.graph_service - INFO - 查询验证通过
2025-12-02 19:40:53,924 - services.graph_service - INFO - 收到执行查询请求: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, f.name AS food_name
2025-12-02 19:40:53,924 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, f.name AS food_name
2025-12-02 19:40:53,954 - services.graph_service - INFO - 查询执行成功，耗时: 0.029秒，返回 15 条记录
2025-12-02 19:40:53,954 - services.graph_service - INFO - 查询执行完成，返回 15 条记录
2025-12-02 19:58:38,736 - services.graph_service - INFO - 收到生成查询请求: 那可以去那里治疗
2025-12-02 19:58:38,827 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 19:58:47,745 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (d:Disease)-[:belongs_to]->(dept:Department)
WHERE d.name = '疾病名称'
RETURN dept.name AS 治疗科室
2025-12-02 19:58:47,788 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 19:59:00,366 - services.graph_service - INFO - 查询解释: 这个Cypher查询是用来在Neo4j图数据库中查找特定疾病所属的治疗科室。让我一步步解释：

**查询目的：**
查找名为"疾病名称"的疾病属于哪个科室。

**查询结构解析：**

1. **`MATCH (d:Disease)-[:belongs_to]->(dept:Department)`**
   - 匹配一个模式：找到标签为"Disease"的节点（用变量`d`表示），这个节点通过`belongs_to`关系指向标签为"Department"的节点（用变量`dept`表示）
   - 这表示"疾病属于科室"的关系

2. **`WHERE d.name = '疾病名称'`**
   - 筛选条件：只选择名称为"疾病名称"的疾病节点
   - 这里的"疾病名称"应该替换为实际要查询的具体疾病名称

3. **`RETURN dept.name AS 治疗科室`**
   - 返回结果：返回科室节点的名称，并将结果列命名为"治疗科室"

**简单来说：**
这个查询就像是在问："名为'疾病名称'的疾病属于哪个科室？" 然后返回该科室的名称。

**实际应用示例：**
如果数据库中有：
- 一个名为"高血压"的疾病节点
- 这个节点通过`belongs_to`关系连接到名为"心血管内科"的科室节点

那么查询 `MATCH (d:Disease)-[:belongs_to]->(dept:Department) WHERE d.name = '高血压' RETURN dept.name AS 治疗科室` 会返回："心血管内科"
2025-12-02 19:59:00,367 - services.graph_service - INFO - 查询验证通过
2025-12-02 19:59:00,375 - services.graph_service - INFO - 收到验证查询请求: MATCH (d:Disease)-[:belongs_to]->(dept:Department)
WHERE d.name = '疾病名称'
RETURN dept.name AS 治疗科室
2025-12-02 19:59:00,375 - services.graph_service - INFO - 查询验证通过
2025-12-02 19:59:00,379 - services.graph_service - INFO - 收到执行查询请求: MATCH (d:Disease)-[:belongs_to]->(dept:Department)
WHERE d.name = '疾病名称'
RETURN dept.name AS 治疗科室
2025-12-02 19:59:00,379 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (d:Disease)-[:belongs_to]->(dept:Department)
WHERE d.name = '疾病名称'
RETURN dept.name AS 治疗科室
2025-12-02 19:59:00,440 - services.graph_service - INFO - 查询执行成功，耗时: 0.061秒，返回 0 条记录
2025-12-02 19:59:00,440 - services.graph_service - INFO - 查询执行完成，返回 0 条记录
2025-12-02 20:59:10,127 - services.graph_service - INFO - Neo4j 连接已关闭
2025-12-02 21:01:58,239 - services.graph_service - INFO - 成功连接到 Neo4j: neo4j://0.0.0.0:7687
2025-12-02 21:02:08,761 - services.graph_service - INFO - 收到生成查询请求: 高血压患者饮食要注意什么？
2025-12-02 21:02:09,133 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 21:02:11,895 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, f.name AS food_name
2025-12-02 21:02:11,939 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-02 21:02:26,840 - services.graph_service - INFO - 查询解释: 这个Cypher查询是用来在Neo4j图数据库中查找与"高血压"相关的食物信息的。让我一步步解释：

## 查询目的
查找所有与"高血压"疾病相关的食物，并显示它们之间的关系类型和食物名称。

## 查询分解

1. **`MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food)`**
   - 匹配模式：查找疾病节点和食物节点之间的连接
   - `(d:Disease)`：标签为"Disease"的节点，别名为d
   - `(f:Food)`：标签为"Food"的节点，别名为f
   - `[r:not_eat|do_eat|recommand_eat]`：三种可能的关系类型：
     - `not_eat`：不能吃
     - `do_eat`：可以吃
     - `recommand_eat`：推荐吃

2. **`WHERE d.name = '高血压'`**
   - 筛选条件：只选择名称为"高血压"的疾病节点

3. **`RETURN type(r) AS relationship_type, f.name AS food_name`**
   - 返回结果：
     - 关系类型（重命名为relationship_type）
     - 食物名称（重命名为food_name）

## 查询结果示例
可能会返回类似这样的结果：
```
relationship_type | food_name
-----------------|-----------
not_eat          | 咸菜
do_eat           | 苹果
recommand_eat    | 芹菜
not_eat          | 肥肉
```

## 简单理解
这个查询相当于问："对于高血压患者，哪些食物是不能吃的、可以吃的或推荐吃的？分别是什么关系？"

这样的查询在医疗健康、饮食建议等应用中很有用，可以帮助用户了解特定疾病的饮食注意事项。
2025-12-02 21:02:26,842 - services.graph_service - INFO - 查询验证通过
2025-12-02 21:02:26,856 - services.graph_service - INFO - 收到验证查询请求: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, f.name AS food_name
2025-12-02 21:02:26,856 - services.graph_service - INFO - 查询验证通过
2025-12-02 21:02:26,860 - services.graph_service - INFO - 收到执行查询请求: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, f.name AS food_name
2025-12-02 21:02:26,861 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, f.name AS food_name
2025-12-02 21:02:26,890 - services.graph_service - INFO - 查询执行成功，耗时: 0.029秒，返回 15 条记录
2025-12-02 21:02:26,890 - services.graph_service - INFO - 查询执行完成，返回 15 条记录
2025-12-03 10:10:11,599 - services.graph_service - INFO - 收到生成查询请求: 我嗓子疼，咳嗽，流鼻涕，有轻微发热，可能是得了什么病，可以吃什么药治疗？
2025-12-03 10:10:11,798 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 10:10:28,377 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (s:Symptom)<-[:has_symptom]-(d:Disease)
WHERE s.name IN ['嗓子疼', '咳嗽', '流鼻涕', '发热']
WITH d, COUNT(s) AS symptom_count
WHERE symptom_count >= 3
RETURN d.name AS disease_name, symptom_count
ORDER BY symptom_count DESC
LIMIT 5
2025-12-03 10:10:28,421 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 10:10:49,069 - services.graph_service - INFO - 查询解释: 这个Cypher查询是用来**找出包含特定症状的疾病**，并**按匹配症状数量排序**。让我一步步解释：

## 查询目的
找出数据库中**至少包含3个指定症状**的疾病，并显示匹配最多的前5种疾病。

## 查询步骤分解：

1. **`MATCH (s:Symptom)<-[:has_symptom]-(d:Disease)`**
   - 匹配模式：查找所有有"has_symptom"关系的节点
   - `d:Disease` → 疾病节点
   - `s:Symptom` → 症状节点
   - `<-[:has_symptom]-` → 关系方向：疾病有症状（疾病指向症状）

2. **`WHERE s.name IN ['嗓子疼', '咳嗽', '流鼻涕', '发热']`**
   - 筛选条件：只关注这4种特定症状
   - 症状名称：嗓子疼、咳嗽、流鼻涕、发热

3. **`WITH d, COUNT(s) AS symptom_count`**
   - 分组统计：对每个疾病(d)，计算它有多少个匹配的症状
   - `symptom_count` → 每个疾病匹配到的症状数量

4. **`WHERE symptom_count >= 3`**
   - 过滤条件：只保留匹配到**至少3个症状**的疾病

5. **`RETURN d.name AS disease_name, symptom_count`**
   - 返回结果：疾病名称和匹配的症状数量

6. **`ORDER BY symptom_count DESC`**
   - 排序：按匹配症状数量**从多到少**排序

7. **`LIMIT 5`**
   - 限制结果：只返回前5条记录

## 实际应用场景
这个查询可以用来：
- **疾病诊断辅助**：当患者有多个症状时，找出可能的疾病
- **流行病分析**：分析特定症状组合对应的常见疾病
- **医疗知识库查询**：快速查找症状对应的疾病

## 示例结果可能包括：
```
disease_name       | symptom_count
-------------------|--------------
普通感冒           | 4
流感               | 4
急性咽炎           | 3
支气管炎          | 3
...
```

简单说：**"找出至少有嗓子疼、咳嗽、流鼻涕、发热中任意3个症状的疾病，按匹配症状数排名前5"**。
2025-12-03 10:10:49,069 - services.graph_service - INFO - 查询验证通过
2025-12-03 10:10:49,077 - services.graph_service - INFO - 收到验证查询请求: MATCH (s:Symptom)<-[:has_symptom]-(d:Disease)
WHERE s.name IN ['嗓子疼', '咳嗽', '流鼻涕', '发热']
WITH d, COUNT(s) AS symptom_count
WHERE symptom_count >= 3
RETURN d.name AS disease_name, symptom_count
ORDER BY symptom_count DESC
LIMIT 5
2025-12-03 10:10:49,077 - services.graph_service - INFO - 查询验证通过
2025-12-03 10:10:49,082 - services.graph_service - INFO - 收到执行查询请求: MATCH (s:Symptom)<-[:has_symptom]-(d:Disease)
WHERE s.name IN ['嗓子疼', '咳嗽', '流鼻涕', '发热']
WITH d, COUNT(s) AS symptom_count
WHERE symptom_count >= 3
RETURN d.name AS disease_name, symptom_count
ORDER BY symptom_count DESC
LIMIT 5
2025-12-03 10:10:49,082 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (s:Symptom)<-[:has_symptom]-(d:Disease)
WHERE s.name IN ['嗓子疼', '咳嗽', '流鼻涕', '发热']
WITH d, COUNT(s) AS symptom_count
WHERE symptom_count >= 3
RETURN d.name AS disease_name, symptom_count
ORDER BY symptom_count DESC
LIMIT 5
2025-12-03 10:10:49,237 - services.graph_service - INFO - 查询执行成功，耗时: 0.155秒，返回 0 条记录
2025-12-03 10:10:49,237 - services.graph_service - INFO - 查询执行完成，返回 0 条记录
2025-12-03 10:12:07,945 - services.graph_service - INFO - 收到生成查询请求: 感冒了可以吃什么药治疗一下，我需要去那个科室，有什么忌口吗？
2025-12-03 10:12:08,047 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 10:12:16,009 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (d:Disease {name: '感冒'})
OPTIONAL MATCH (d)-[:recommand_drug|command_drug]-(drug:Drug)
OPTIONAL MATCH (d)-[:belongs_to]-(dept:Department)
OPTIONAL MATCH (d)-[:not_eat]-(avoid_food:Food)
RETURN 
  COLLECT(DISTINCT drug.name) AS recommended_drugs,
  COLLECT(DISTINCT dept.name) AS departments,
  COLLECT(DISTINCT avoid_food.name) AS foods_to_avoid
2025-12-03 10:12:16,056 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 10:12:31,539 - services.graph_service - INFO - 查询解释: 这个Cypher查询用于从Neo4j图数据库中查找与"感冒"这种疾病相关的信息。让我一步步解释：

## 查询目的
查找"感冒"的推荐药物、所属科室和需要避免的食物。

## 查询分解

1. **`MATCH (d:Disease {name: '感冒'})`**
   - 找到名为"感冒"的疾病节点

2. **`OPTIONAL MATCH (d)-[:recommand_drug|command_drug]-(drug:Drug)`**
   - 查找与感冒相关的药物（通过`recommand_drug`或`command_drug`关系）
   - `OPTIONAL`表示即使没有相关药物，查询也会继续执行

3. **`OPTIONAL MATCH (d)-[:belongs_to]-(dept:Department)`**
   - 查找感冒所属的科室

4. **`OPTIONAL MATCH (d)-[:not_eat]-(avoid_food:Food)`**
   - 查找感冒患者需要避免的食物

5. **`RETURN`部分**
   - `COLLECT(DISTINCT drug.name)`：收集所有不重复的药物名称
   - `COLLECT(DISTINCT dept.name)`：收集所有不重复的科室名称
   - `COLLECT(DISTINCT avoid_food.name)`：收集所有不重复的需要避免的食物名称

## 返回结果
查询会返回一个包含三个字段的结果：
- `recommended_drugs`：推荐药物列表
- `departments`：相关科室列表  
- `foods_to_avoid`：需要避免的食物列表

## 简单理解
这个查询就像是问："感冒应该吃什么药？去哪个科室看病？生病期间不能吃什么？"

**注意**：查询中有一个拼写问题 - `recommand_drug`应该是`recommend_drug`（推荐药物），但查询同时考虑了两种拼写方式。
2025-12-03 10:12:31,540 - services.graph_service - INFO - 查询验证通过
2025-12-03 10:12:31,551 - services.graph_service - INFO - 收到验证查询请求: MATCH (d:Disease {name: '感冒'})
OPTIONAL MATCH (d)-[:recommand_drug|command_drug]-(drug:Drug)
OPTIONAL MATCH (d)-[:belongs_to]-(dept:Department)
OPTIONAL MATCH (d)-[:not_eat]-(avoid_food:Food)
RETURN 
  COLLECT(DISTINCT drug.name) AS recommended_drugs,
  COLLECT(DISTINCT dept.name) AS departments,
  COLLECT(DISTINCT avoid_food.name) AS foods_to_avoid
2025-12-03 10:12:31,551 - services.graph_service - INFO - 查询验证通过
2025-12-03 10:12:31,556 - services.graph_service - INFO - 收到执行查询请求: MATCH (d:Disease {name: '感冒'})
OPTIONAL MATCH (d)-[:recommand_drug|command_drug]-(drug:Drug)
OPTIONAL MATCH (d)-[:belongs_to]-(dept:Department)
OPTIONAL MATCH (d)-[:not_eat]-(avoid_food:Food)
RETURN 
  COLLECT(DISTINCT drug.name) AS recommended_drugs,
  COLLECT(DISTINCT dept.name) AS departments,
  COLLECT(DISTINCT avoid_food.name) AS foods_to_avoid
2025-12-03 10:12:31,556 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (d:Disease {name: '感冒'})
OPTIONAL MATCH (d)-[:recommand_drug|command_drug]-(drug:Drug)
OPTIONAL MATCH (d)-[:belongs_to]-(dept:Department)
OPTIONAL MATCH (d)-[:not_eat]-(avoid_food:Food)
RETURN 
  COLLECT(DISTINCT drug.name) AS recommended_drugs,
  COLLECT(DISTINCT dept.name) AS departments,
  COLLECT(DISTINCT avoid_food.name) AS foods_to_avoid
2025-12-03 10:12:31,694 - services.graph_service - INFO - 查询执行成功，耗时: 0.137秒，返回 1 条记录
2025-12-03 10:12:31,694 - services.graph_service - INFO - 查询执行完成，返回 1 条记录
2025-12-03 10:13:14,367 - services.graph_service - INFO - Neo4j 连接已关闭
2025-12-03 10:31:27,508 - services.graph_service - INFO - 成功连接到 Neo4j: neo4j://0.0.0.0:7687
2025-12-03 10:32:46,884 - services.graph_service - INFO - 收到生成查询请求: 嗓子疼，吃什么药品，什么能吃，什么不能吃？
2025-12-03 10:32:47,235 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 10:32:53,817 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (d:Disease)-[:has_symptom]->(s:Symptom)
WHERE s.name CONTAINS '嗓子疼'
WITH d
MATCH (d)-[:command_drug|recommand_drug]->(drug:Drug)
OPTIONAL MATCH (d)-[:do_eat|recommand_eat]->(good_food:Food)
OPTIONAL MATCH (d)-[:not_eat]->(bad_food:Food)
RETURN DISTINCT 
    d.name AS disease_name,
    COLLECT(DISTINCT drug.name) AS recommended_drugs,
    COLLECT(DISTINCT good_food.name) AS recommended_foods,
    COLLECT(DISTINCT bad_food.name AS foods_to_avoid)
2025-12-03 10:32:53,862 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 10:33:16,096 - services.graph_service - INFO - 查询解释: 我来用简单的方式解释这个Cypher查询：

## 这个查询在做什么？

这个查询是**根据症状查找相关疾病，并获取该疾病的治疗建议**。

## 分步解释：

### 第一步：找疾病
```cypher
MATCH (d:Disease)-[:has_symptom]->(s:Symptom)
WHERE s.name CONTAINS '嗓子疼'
```
- 在知识图谱中找到所有有"嗓子疼"症状的疾病
- `d` 代表疾病节点
- `s` 代表症状节点
- `CONTAINS '嗓子疼'` 表示症状名称包含"嗓子疼"（比如"嗓子疼"、"喉咙嗓子疼"等）

### 第二步：收集相关药物
```cypher
WITH d
MATCH (d)-[:command_drug|recommand_drug]->(drug:Drug)
```
- 对找到的每个疾病，查找推荐的药物
- `command_drug|recommand_drug` 表示两种关系都可以（可能是拼写变体）
- `drug` 代表药物节点

### 第三步：查找饮食建议（可选）
```cypher
OPTIONAL MATCH (d)-[:do_eat|recommand_eat]->(good_food:Food)
OPTIONAL MATCH (d)-[:not_eat]->(bad_food:Food)
```
- 查找推荐吃的食物（`good_food`）
- 查找不建议吃的食物（`bad_food`）
- `OPTIONAL` 表示这些信息可能有也可能没有

### 第四步：整理返回结果
```cypher
RETURN DISTINCT 
    d.name AS disease_name,
    COLLECT(DISTINCT drug.name) AS recommended_drugs,
    COLLECT(DISTINCT good_food.name) AS recommended_foods,
    COLLECT(DISTINCT bad_food.name) AS foods_to_avoid
```
- 返回疾病名称
- 把所有推荐的药物名称收集成一个列表
- 把所有推荐的食物收集成一个列表  
- 把所有不建议吃的食物收集成一个列表
- `DISTINCT` 确保没有重复项

## 简单来说：

**"帮我找所有会引起嗓子疼的疾病，并告诉我每个病应该吃什么药、推荐吃什么食物、避免吃什么食物。"**

## 返回结果示例：
```
疾病名称       | 推荐药物          | 推荐食物      | 避免食物
--------------|------------------|--------------|----------
感冒          | [感冒灵,阿莫西林] | [姜汤,蜂蜜水] | [冰水,辣椒]
扁桃体炎      | [青霉素,消炎药]   | [温开水]      | [油炸食品]
```

这个查询在医疗知识图谱或健康咨询系统中很常见，用于提供综合的健康建议。
2025-12-03 10:33:16,099 - services.graph_service - INFO - 查询验证通过
2025-12-03 10:33:16,118 - services.graph_service - INFO - 收到验证查询请求: MATCH (d:Disease)-[:has_symptom]->(s:Symptom)
WHERE s.name CONTAINS '嗓子疼'
WITH d
MATCH (d)-[:command_drug|recommand_drug]->(drug:Drug)
OPTIONAL MATCH (d)-[:do_eat|recommand_eat]->(good_food:Food)
OPTIONAL MATCH (d)-[:not_eat]->(bad_food:Food)
RETURN DISTINCT 
    d.name AS disease_name,
    COLLECT(DISTINCT drug.name) AS recommended_drugs,
    COLLECT(DISTINCT good_food.name) AS recommended_foods,
    COLLECT(DISTINCT bad_food.name AS foods_to_avoid)
2025-12-03 10:33:16,118 - services.graph_service - INFO - 查询验证通过
2025-12-03 10:33:16,122 - services.graph_service - INFO - 收到执行查询请求: MATCH (d:Disease)-[:has_symptom]->(s:Symptom)
WHERE s.name CONTAINS '嗓子疼'
WITH d
MATCH (d)-[:command_drug|recommand_drug]->(drug:Drug)
OPTIONAL MATCH (d)-[:do_eat|recommand_eat]->(good_food:Food)
OPTIONAL MATCH (d)-[:not_eat]->(bad_food:Food)
RETURN DISTINCT 
    d.name AS disease_name,
    COLLECT(DISTINCT drug.name) AS recommended_drugs,
    COLLECT(DISTINCT good_food.name) AS recommended_foods,
    COLLECT(DISTINCT bad_food.name AS foods_to_avoid)
2025-12-03 10:33:16,122 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (d:Disease)-[:has_symptom]->(s:Symptom)
WHERE s.name CONTAINS '嗓子疼'
WITH d
MATCH (d)-[:command_drug|recommand_drug]->(drug:Drug)
OPTIONAL MATCH (d)-[:do_eat|recommand_eat]->(good_food:Food)
OPTIONAL MATCH (d)-[:not_eat]->(bad_food:Food)
RETURN DISTINCT 
    d.name AS disease_name,
    COLLECT(DISTINCT drug.name) AS recommended_drugs,
    COLLECT(DISTINCT good_food.name) AS recommended_foods,
    COLLECT(DISTINCT bad_food.name AS foods_to_avoid)
2025-12-03 10:33:16,204 - services.graph_service - ERROR - 查询执行失败，耗时: 0.081秒，错误: {code: Neo.ClientError.Statement.SyntaxError} {message: Invalid input 'AS': expected an expression, ')' or ',' (line 11, column 36 (offset: 436))
"    COLLECT(DISTINCT bad_food.name AS foods_to_avoid)"
                                    ^}
2025-12-03 10:36:42,669 - services.graph_service - INFO - Neo4j 连接已关闭
2025-12-03 10:36:47,070 - services.graph_service - INFO - 成功连接到 Neo4j: neo4j://0.0.0.0:7687
2025-12-03 10:37:24,138 - services.graph_service - INFO - 收到生成查询请求: 感冒了嗓子疼，打喷嚏，应该吃什么药，什么能吃，什么不能吃
2025-12-03 10:37:24,519 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 10:37:46,065 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (d:Disease)-[:has_symptom]->(s:Symptom)
WHERE s.name IN ['嗓子疼', '打喷嚏']
WITH d, COLLECT(DISTINCT s.name) AS matched_symptoms
WHERE size(matched_symptoms) >= 2
RETURN d.name AS disease_name, matched_symptoms
LIMIT 1
2025-12-03 10:37:46,116 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 10:38:01,447 - services.graph_service - INFO - 查询解释: 这个Cypher查询是用来在医疗知识图谱中查找疾病的。让我一步步解释：

## 查询目的
查找**同时包含"嗓子疼"和"打喷嚏"这两个症状**的疾病。

## 查询步骤分解：

1. **匹配模式**
   ```
   MATCH (d:Disease)-[:has_symptom]->(s:Symptom)
   ```
   - 查找所有疾病节点（标签为`Disease`）
   - 这些疾病通过`has_symptom`关系连接到症状节点（标签为`Symptom`）

2. **筛选症状**
   ```
   WHERE s.name IN ['嗓子疼', '打喷嚏']
   ```
   - 只保留症状名称为"嗓子疼"或"打喷嚏"的记录

3. **分组统计**
   ```
   WITH d, COLLECT(DISTINCT s.name) AS matched_symptoms
   ```
   - 按疾病分组
   - 收集每个疾病匹配到的症状名称（去重）

4. **筛选疾病**
   ```
   WHERE size(matched_symptoms) >= 2
   ```
   - 只保留匹配到**至少2个**指定症状的疾病
   - 这意味着疾病必须同时有"嗓子疼"和"打喷嚏"两个症状

5. **返回结果**
   ```
   RETURN d.name AS disease_name, matched_symptoms
   LIMIT 1
   ```
   - 返回疾病名称和匹配到的症状列表
   - `LIMIT 1`表示只返回第一个匹配结果

## 实际应用场景
这个查询类似于：
- "我嗓子疼还打喷嚏，可能是什么病？"
- 系统会找出同时包含这两个症状的疾病，比如可能是**感冒**或**流感**

## 简单理解
就像在问："哪些病会让人既嗓子疼又打喷嚏？给我找一个这样的病看看。"
2025-12-03 10:38:01,449 - services.graph_service - INFO - 查询验证通过
2025-12-03 10:38:01,463 - services.graph_service - INFO - 收到验证查询请求: MATCH (d:Disease)-[:has_symptom]->(s:Symptom)
WHERE s.name IN ['嗓子疼', '打喷嚏']
WITH d, COLLECT(DISTINCT s.name) AS matched_symptoms
WHERE size(matched_symptoms) >= 2
RETURN d.name AS disease_name, matched_symptoms
LIMIT 1
2025-12-03 10:38:01,463 - services.graph_service - INFO - 查询验证通过
2025-12-03 10:38:01,469 - services.graph_service - INFO - 收到执行查询请求: MATCH (d:Disease)-[:has_symptom]->(s:Symptom)
WHERE s.name IN ['嗓子疼', '打喷嚏']
WITH d, COLLECT(DISTINCT s.name) AS matched_symptoms
WHERE size(matched_symptoms) >= 2
RETURN d.name AS disease_name, matched_symptoms
LIMIT 1
2025-12-03 10:38:01,469 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (d:Disease)-[:has_symptom]->(s:Symptom)
WHERE s.name IN ['嗓子疼', '打喷嚏']
WITH d, COLLECT(DISTINCT s.name) AS matched_symptoms
WHERE size(matched_symptoms) >= 2
RETURN d.name AS disease_name, matched_symptoms
LIMIT 1
2025-12-03 10:38:01,575 - services.graph_service - INFO - 查询执行成功，耗时: 0.105秒，返回 0 条记录
2025-12-03 10:38:01,575 - services.graph_service - INFO - 查询执行完成，返回 0 条记录
2025-12-03 10:39:04,815 - services.graph_service - INFO - 收到生成查询请求: 高血压有什么症状，有什么治疗的药品吗？
2025-12-03 10:39:04,927 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 10:39:08,987 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (d:Disease {name: '高血压'})
OPTIONAL MATCH (d)-[:has_symptom]->(s:Symptom)
OPTIONAL MATCH (d)-[:recommand_drug|command_drug]->(drug:Drug)
RETURN 
  d.name AS disease_name,
  COLLECT(DISTINCT s.name) AS symptoms,
  COLLECT(DISTINCT drug.name) AS recommended_drugs
2025-12-03 10:39:09,032 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 10:39:28,238 - services.graph_service - INFO - 查询解释: 这个Cypher查询是用来从Neo4j图数据库中查找关于"高血压"疾病的信息。让我一步步解释：

## 查询目的
查找名为"高血压"的疾病，并获取它的相关症状和推荐药物。

## 查询分解

1. **`MATCH (d:Disease {name: '高血压'})`**
   - 找到标签为"Disease"且名字为"高血压"的节点
   - 把这个节点赋值给变量`d`

2. **`OPTIONAL MATCH (d)-[:has_symptom]->(s:Symptom)`**
   - 可选匹配：查找从疾病节点`d`通过"has_symptom"关系连接的所有症状节点
   - 如果存在这样的关系，就把症状节点赋值给变量`s`
   - 使用`OPTIONAL`意味着即使没有症状信息，查询也不会失败

3. **`OPTIONAL MATCH (d)-[:recommand_drug|command_drug]->(drug:Drug)`**
   - 另一个可选匹配：查找从疾病节点`d`通过"recommand_drug"或"command_drug"关系连接的所有药物节点
   - 注意：这里有两个可能的关系类型，用`|`分隔
   - 把药物节点赋值给变量`drug`

4. **`RETURN`部分**
   - `d.name AS disease_name`：返回疾病名称
   - `COLLECT(DISTINCT s.name) AS symptoms`：收集所有不重复的症状名称到一个列表中
   - `COLLECT(DISTINCT drug.name) AS recommended_drugs`：收集所有不重复的药物名称到一个列表中

## 查询结果
查询会返回一行数据，包含三个字段：
- `disease_name`: "高血压"
- `symptoms`: 所有相关症状的列表（如：["头痛", "头晕", "心悸"]）
- `recommended_drugs`: 所有推荐药物的列表（如：["降压药A", "降压药B"]）

## 特点
- 使用`OPTIONAL MATCH`确保即使某些信息缺失，查询仍能返回结果
- 使用`DISTINCT`避免重复数据
- 使用`COLLECT()`将多个值聚合为列表

简单说：**这个查询查找高血压疾病，并收集它的所有症状和推荐药物，以结构化的方式返回结果。**
2025-12-03 10:39:28,241 - services.graph_service - INFO - 查询验证通过
2025-12-03 10:39:28,265 - services.graph_service - INFO - 收到验证查询请求: MATCH (d:Disease {name: '高血压'})
OPTIONAL MATCH (d)-[:has_symptom]->(s:Symptom)
OPTIONAL MATCH (d)-[:recommand_drug|command_drug]->(drug:Drug)
RETURN 
  d.name AS disease_name,
  COLLECT(DISTINCT s.name) AS symptoms,
  COLLECT(DISTINCT drug.name) AS recommended_drugs
2025-12-03 10:39:28,266 - services.graph_service - INFO - 查询验证通过
2025-12-03 10:39:28,273 - services.graph_service - INFO - 收到执行查询请求: MATCH (d:Disease {name: '高血压'})
OPTIONAL MATCH (d)-[:has_symptom]->(s:Symptom)
OPTIONAL MATCH (d)-[:recommand_drug|command_drug]->(drug:Drug)
RETURN 
  d.name AS disease_name,
  COLLECT(DISTINCT s.name) AS symptoms,
  COLLECT(DISTINCT drug.name) AS recommended_drugs
2025-12-03 10:39:28,274 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (d:Disease {name: '高血压'})
OPTIONAL MATCH (d)-[:has_symptom]->(s:Symptom)
OPTIONAL MATCH (d)-[:recommand_drug|command_drug]->(drug:Drug)
RETURN 
  d.name AS disease_name,
  COLLECT(DISTINCT s.name) AS symptoms,
  COLLECT(DISTINCT drug.name) AS recommended_drugs
2025-12-03 10:39:28,361 - services.graph_service - INFO - 查询执行成功，耗时: 0.087秒，返回 1 条记录
2025-12-03 10:39:28,361 - services.graph_service - INFO - 查询执行完成，返回 1 条记录
2025-12-03 10:45:11,220 - services.graph_service - INFO - Neo4j 连接已关闭
2025-12-03 10:50:42,824 - services.graph_service - INFO - 成功连接到 Neo4j: neo4j://0.0.0.0:7687
2025-12-03 10:50:46,584 - services.graph_service - INFO - Neo4j 连接已关闭
2025-12-03 10:53:39,223 - services.graph_service - INFO - 成功连接到 Neo4j: neo4j://0.0.0.0:7687
2025-12-03 10:56:14,332 - services.graph_service - INFO - 收到生成查询请求: 高血压患者饮食要注意什么？
2025-12-03 10:56:15,121 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 10:56:18,242 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names
2025-12-03 10:56:18,281 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 10:56:32,832 - services.graph_service - INFO - 查询解释: 这个Cypher查询是用来查找与"高血压"相关的食物的，它会返回不同类型的饮食建议以及对应的食物列表。

让我详细解释一下：

**查询目的：**
查找高血压患者应该避免、可以吃或推荐吃的食物

**查询逻辑：**

1. **`MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food)`**
   - 匹配疾病节点和食物节点之间的关系
   - 关系类型有三种：`not_eat`（不能吃）、`do_eat`（可以吃）、`recommand_eat`（推荐吃）
   - `d`代表疾病节点，`f`代表食物节点，`r`代表它们之间的关系

2. **`WHERE d.name = '高血压'`**
   - 只查找疾病名称为"高血压"的记录

3. **`RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names`**
   - 返回两个结果：
     - `relationship_type`：关系类型（不能吃/可以吃/推荐吃）
     - `food_names`：对应关系下的所有食物名称（使用`COLLECT`函数将多个食物名称收集到一个列表中，`DISTINCT`确保没有重复）

**查询结果示例：**
```
relationship_type | food_names
-----------------|-------------------
"not_eat"        | ["咸菜", "腊肉", "油炸食品"]
"do_eat"         | ["苹果", "香蕉", "全麦面包"]
"recommand_eat"  | ["芹菜", "海带", "黑木耳"]
```

简单来说，这个查询就是**找出高血压患者需要避免、可以正常吃和推荐多吃的所有食物，并按类别分组显示**。
2025-12-03 10:56:32,833 - services.graph_service - INFO - 查询验证通过
2025-12-03 10:56:32,846 - services.graph_service - INFO - 收到验证查询请求: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names
2025-12-03 10:56:32,846 - services.graph_service - INFO - 查询验证通过
2025-12-03 10:56:32,854 - services.graph_service - INFO - 收到执行查询请求: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names
2025-12-03 10:56:32,854 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names
2025-12-03 10:56:32,990 - services.graph_service - INFO - 查询执行成功，耗时: 0.135秒，返回 3 条记录
2025-12-03 10:56:32,990 - services.graph_service - INFO - 查询执行完成，返回 3 条记录
2025-12-03 11:11:26,113 - services.graph_service - INFO - 收到生成查询请求: 感冒了有什么症状，应该吃什么治疗，药品制造商是谁，有什么并发症吗？
2025-12-03 11:11:26,244 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 11:11:33,269 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (disease:Disease {name: '感冒'})
OPTIONAL MATCH (disease)-[:has_symptom]->(symptom:Symptom)
OPTIONAL MATCH (disease)-[:recommand_eat]->(food:Food)
OPTIONAL MATCH (disease)-[:command_drug]->(drug:Drug)
OPTIONAL MATCH (drug)-[:drugs_of]->(producer:Producer)
OPTIONAL MATCH (disease)-[:acompany_with]->(complication:Disease)
RETURN 
  COLLECT(DISTINCT symptom.name) AS symptoms,
  COLLECT(DISTINCT food.name) AS recommended_foods,
  COLLECT(DISTINCT drug.name) AS recommended_drugs,
  COLLECT(DISTINCT producer.name) AS drug_producers,
  COLLECT(DISTINCT complication.name) AS complications
2025-12-03 11:11:33,346 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 11:11:51,579 - services.graph_service - INFO - 查询解释: 这个Cypher查询是用来从图数据库中查找与"感冒"这种疾病相关的各种信息。让我一步步解释：

## 查询目的
查找"感冒"的：
- 症状
- 推荐食物
- 推荐药物
- 药物生产商
- 可能并发症

## 查询结构解析

### 1. 主匹配
```cypher
MATCH (disease:Disease {name: '感冒'})
```
找到标签为"Disease"且名字是"感冒"的节点

### 2. 可选匹配（5个部分）
每个`OPTIONAL MATCH`都是可选的，意味着即使某些关系不存在，查询也不会失败：

- **症状**：`(disease)-[:has_symptom]->(symptom:Symptom)`
  查找感冒的所有症状

- **推荐食物**：`(disease)-[:recommand_eat]->(food:Food)`
  查找感冒时推荐吃的食物

- **推荐药物**：`(disease)-[:command_drug]->(drug:Drug)`
  查找感冒时推荐的药物

- **药物生产商**：`(drug)-[:drugs_of]->(producer:Producer)`
  查找这些药物对应的生产商

- **并发症**：`(disease)-[:acompany_with]->(complication:Disease)`
  查找可能伴随感冒出现的其他疾病

### 3. 返回结果
使用`COLLECT(DISTINCT ...)`将结果聚合成数组：
- `symptoms`：所有症状名称的数组
- `recommended_foods`：所有推荐食物名称的数组
- `recommended_drugs`：所有推荐药物名称的数组
- `drug_producers`：所有药物生产商名称的数组
- `complications`：所有并发症名称的数组

## 结果示例
查询可能返回类似这样的结果：
```json
{
  "symptoms": ["发烧", "咳嗽", "流鼻涕", "头痛"],
  "recommended_foods": ["姜茶", "鸡汤", "柠檬水"],
  "recommended_drugs": ["感冒灵", "板蓝根"],
  "drug_producers": ["白云山", "同仁堂"],
  "complications": ["支气管炎", "肺炎"]
}
```

这个查询非常适合医疗知识图谱应用，可以一次性获取疾病的全方位信息。
2025-12-03 11:11:51,582 - services.graph_service - INFO - 查询验证通过
2025-12-03 11:11:51,592 - services.graph_service - INFO - 收到验证查询请求: MATCH (disease:Disease {name: '感冒'})
OPTIONAL MATCH (disease)-[:has_symptom]->(symptom:Symptom)
OPTIONAL MATCH (disease)-[:recommand_eat]->(food:Food)
OPTIONAL MATCH (disease)-[:command_drug]->(drug:Drug)
OPTIONAL MATCH (drug)-[:drugs_of]->(producer:Producer)
OPTIONAL MATCH (disease)-[:acompany_with]->(complication:Disease)
RETURN 
  COLLECT(DISTINCT symptom.name) AS symptoms,
  COLLECT(DISTINCT food.name) AS recommended_foods,
  COLLECT(DISTINCT drug.name) AS recommended_drugs,
  COLLECT(DISTINCT producer.name) AS drug_producers,
  COLLECT(DISTINCT complication.name) AS complications
2025-12-03 11:11:51,592 - services.graph_service - INFO - 查询验证通过
2025-12-03 11:11:51,598 - services.graph_service - INFO - 收到执行查询请求: MATCH (disease:Disease {name: '感冒'})
OPTIONAL MATCH (disease)-[:has_symptom]->(symptom:Symptom)
OPTIONAL MATCH (disease)-[:recommand_eat]->(food:Food)
OPTIONAL MATCH (disease)-[:command_drug]->(drug:Drug)
OPTIONAL MATCH (drug)-[:drugs_of]->(producer:Producer)
OPTIONAL MATCH (disease)-[:acompany_with]->(complication:Disease)
RETURN 
  COLLECT(DISTINCT symptom.name) AS symptoms,
  COLLECT(DISTINCT food.name) AS recommended_foods,
  COLLECT(DISTINCT drug.name) AS recommended_drugs,
  COLLECT(DISTINCT producer.name) AS drug_producers,
  COLLECT(DISTINCT complication.name) AS complications
2025-12-03 11:11:51,598 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (disease:Disease {name: '感冒'})
OPTIONAL MATCH (disease)-[:has_symptom]->(symptom:Symptom)
OPTIONAL MATCH (disease)-[:recommand_eat]->(food:Food)
OPTIONAL MATCH (disease)-[:command_drug]->(drug:Drug)
OPTIONAL MATCH (drug)-[:drugs_of]->(producer:Producer)
OPTIONAL MATCH (disease)-[:acompany_with]->(complication:Disease)
RETURN 
  COLLECT(DISTINCT symptom.name) AS symptoms,
  COLLECT(DISTINCT food.name) AS recommended_foods,
  COLLECT(DISTINCT drug.name) AS recommended_drugs,
  COLLECT(DISTINCT producer.name) AS drug_producers,
  COLLECT(DISTINCT complication.name) AS complications
2025-12-03 11:11:51,869 - neo4j.notifications - WARNING - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownRelationshipTypeWarning} {category: UNRECOGNIZED} {title: The provided relationship type is not in the database.} {description: One of the relationship types in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing relationship type is: drugs_of)} {position: line: 5, column: 25, offset: 229} for query: "MATCH (disease:Disease {name: '感冒'})\nOPTIONAL MATCH (disease)-[:has_symptom]->(symptom:Symptom)\nOPTIONAL MATCH (disease)-[:recommand_eat]->(food:Food)\nOPTIONAL MATCH (disease)-[:command_drug]->(drug:Drug)\nOPTIONAL MATCH (drug)-[:drugs_of]->(producer:Producer)\nOPTIONAL MATCH (disease)-[:acompany_with]->(complication:Disease)\nRETURN \n  COLLECT(DISTINCT symptom.name) AS symptoms,\n  COLLECT(DISTINCT food.name) AS recommended_foods,\n  COLLECT(DISTINCT drug.name) AS recommended_drugs,\n  COLLECT(DISTINCT producer.name) AS drug_producers,\n  COLLECT(DISTINCT complication.name) AS complications"
2025-12-03 11:11:51,870 - services.graph_service - INFO - 查询执行成功，耗时: 0.272秒，返回 1 条记录
2025-12-03 11:11:51,870 - services.graph_service - INFO - 查询执行完成，返回 1 条记录
2025-12-03 11:28:56,854 - services.graph_service - INFO - 收到生成查询请求: 高血压患者饮食要注意什么？
2025-12-03 11:28:57,007 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 11:28:59,969 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names
2025-12-03 11:29:00,023 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 11:29:13,769 - services.graph_service - INFO - 查询解释: 这个Cypher查询是用来查找与"高血压"相关的食物的，它会返回三种不同类型的食物关系。让我详细解释一下：

**查询目的：**
查找与"高血压"疾病相关的所有食物，并按照不同的饮食建议类型进行分组。

**查询分解：**

1. **`MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food)`**
   - 匹配疾病节点和食物节点之间的三种关系：
     - `not_eat`：不能吃的食物
     - `do_eat`：可以吃的食物  
     - `recommand_eat`：推荐吃的食物
   - `d` 代表疾病节点，`f` 代表食物节点，`r` 代表它们之间的关系

2. **`WHERE d.name = '高血压'`**
   - 只查找疾病名称为"高血压"的节点

3. **`RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names`**
   - 返回两个结果：
     - `relationship_type`：关系类型（不能吃/可以吃/推荐吃）
     - `food_names`：对应关系下的所有食物名称列表（使用`DISTINCT`去重）

**查询结果示例：**
```
relationship_type | food_names
-----------------|-------------------
"not_eat"        | ["咸菜", "腊肉", "油炸食品"]
"do_eat"         | ["苹果", "香蕉", "芹菜"]
"recommand_eat"  | ["燕麦", "深海鱼", "坚果"]
```

**简单来说：** 这个查询就是找出高血压患者"不能吃"、"可以吃"和"推荐吃"的所有食物，并分别列出清单。
2025-12-03 11:29:13,770 - services.graph_service - INFO - 查询验证通过
2025-12-03 11:29:13,775 - services.graph_service - INFO - 收到验证查询请求: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names
2025-12-03 11:29:13,775 - services.graph_service - INFO - 查询验证通过
2025-12-03 11:29:13,778 - services.graph_service - INFO - 收到执行查询请求: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names
2025-12-03 11:29:13,778 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names
2025-12-03 11:29:13,812 - services.graph_service - INFO - 查询执行成功，耗时: 0.033秒，返回 3 条记录
2025-12-03 11:29:13,812 - services.graph_service - INFO - 查询执行完成，返回 3 条记录
2025-12-03 11:31:55,854 - services.graph_service - INFO - 收到生成查询请求: 高血压患者饮食要注意什么？
2025-12-03 11:31:55,984 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 11:31:59,255 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names
2025-12-03 11:31:59,323 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 11:32:13,078 - services.graph_service - INFO - 查询解释: 这个Cypher查询是用来查找与"高血压"相关的食物的，它会返回三种不同类型的食物关系。让我详细解释一下：

**查询目的：**
查找与"高血压"疾病相关的所有食物，并按照不同的饮食建议类型进行分组。

**查询分解：**

1. **`MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food)`**
   - 匹配疾病节点和食物节点之间的三种关系：
     - `not_eat`：不建议吃的食物
     - `do_eat`：可以吃的食物  
     - `recommand_eat`：推荐吃的食物
   - `d`代表疾病节点，`f`代表食物节点，`r`代表它们之间的关系

2. **`WHERE d.name = '高血压'`**
   - 只查找疾病名称为"高血压"的节点

3. **`RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names`**
   - 返回两个结果：
     - `relationship_type`：关系类型（not_eat、do_eat或recommand_eat）
     - `food_names`：每种关系类型对应的食物名称列表（使用`DISTINCT`确保食物名称不重复）

**查询结果示例：**
可能会返回类似这样的结果：
```
relationship_type | food_names
-----------------|-------------------
not_eat          | ["咸菜", "腊肉", "油炸食品"]
do_eat           | ["苹果", "香蕉", "全麦面包"]
recommand_eat    | ["芹菜", "海带", "燕麦"]
```

**简单来说：**
这个查询就是找出高血压患者"不能吃"、"可以吃"和"推荐吃"的所有食物，并分别列出清单。
2025-12-03 11:32:13,079 - services.graph_service - INFO - 查询验证通过
2025-12-03 11:32:13,086 - services.graph_service - INFO - 收到验证查询请求: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names
2025-12-03 11:32:13,086 - services.graph_service - INFO - 查询验证通过
2025-12-03 11:32:13,094 - services.graph_service - INFO - 收到执行查询请求: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names
2025-12-03 11:32:13,094 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names
2025-12-03 11:32:13,136 - services.graph_service - INFO - 查询执行成功，耗时: 0.041秒，返回 3 条记录
2025-12-03 11:32:13,136 - services.graph_service - INFO - 查询执行完成，返回 3 条记录
2025-12-03 11:34:36,441 - services.graph_service - INFO - 收到生成查询请求: 高血压患者饮食要注意什么？
2025-12-03 11:34:36,564 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 11:34:39,513 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names
2025-12-03 11:34:39,591 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 11:34:53,344 - services.graph_service - INFO - 查询解释: 这个Cypher查询是用来查找与"高血压"相关的食物的，它会返回三种不同类型的饮食建议以及对应的食物列表。

让我一步步解释：

**查询目的：**
查找高血压患者应该避免、可以吃或推荐吃的食物。

**查询结构：**

1. **`MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food)`**
   - 匹配疾病节点和食物节点之间的关系
   - `d:Disease`：表示疾病节点
   - `f:Food`：表示食物节点
   - `[r:not_eat|do_eat|recommand_eat]`：匹配三种类型的关系：
     - `not_eat`：不应该吃的食物
     - `do_eat`：可以吃的食物  
     - `recommand_eat`：推荐吃的食物

2. **`WHERE d.name = '高血压'`**
   - 只查找疾病名称为"高血压"的记录

3. **`RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names`**
   - 返回两个结果：
     - `relationship_type`：关系类型（not_eat/do_eat/recommand_eat）
     - `food_names`：对应关系下的所有食物名称（去重后合并成列表）

**查询结果示例：**
```
relationship_type | food_names
-----------------|-------------------
not_eat          | ["咸菜", "腊肉", "油炸食品"]
do_eat           | ["苹果", "香蕉", "蔬菜"]
recommand_eat    | ["燕麦", "芹菜", "黑木耳"]
```

简单来说，这个查询就是**找出高血压患者需要忌口、可以正常吃和推荐多吃的各种食物清单**。
2025-12-03 11:34:53,345 - services.graph_service - INFO - 查询验证通过
2025-12-03 11:34:53,355 - services.graph_service - INFO - 收到验证查询请求: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names
2025-12-03 11:34:53,355 - services.graph_service - INFO - 查询验证通过
2025-12-03 11:34:53,361 - services.graph_service - INFO - 收到执行查询请求: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names
2025-12-03 11:34:53,362 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names
2025-12-03 11:34:53,415 - services.graph_service - INFO - 查询执行成功，耗时: 0.053秒，返回 3 条记录
2025-12-03 11:34:53,415 - services.graph_service - INFO - 查询执行完成，返回 3 条记录
2025-12-03 11:39:16,933 - services.graph_service - INFO - Neo4j 连接已关闭
2025-12-03 11:39:18,963 - services.graph_service - INFO - 成功连接到 Neo4j: neo4j://0.0.0.0:7687
2025-12-03 11:39:24,278 - services.graph_service - INFO - 收到生成查询请求: 高血压患者饮食要注意什么？
2025-12-03 11:39:24,641 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 11:39:27,792 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names
2025-12-03 11:39:27,835 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 11:39:41,425 - services.graph_service - INFO - 查询解释: 这个Cypher查询是用来查找与"高血压"相关的食物的，它会返回不同类型的饮食建议以及对应的食物列表。

让我一步步解释：

**1. MATCH部分：**
- `(d:Disease)`：查找标签为"Disease"的节点（代表疾病）
- `(f:Food)`：查找标签为"Food"的节点（代表食物）
- `-[r:not_eat|do_eat|recommand_eat]-`：查找疾病和食物之间的三种关系类型：
  - `not_eat`：不能吃的食物
  - `do_eat`：可以吃的食物  
  - `recommand_eat`：推荐吃的食物

**2. WHERE部分：**
- `d.name = '高血压'`：只选择疾病名称为"高血压"的节点

**3. RETURN部分：**
- `type(r) AS relationship_type`：返回关系类型（不能吃/可以吃/推荐吃）
- `COLLECT(DISTINCT f.name) AS food_names`：将食物名称收集成一个列表，并去重

**简单来说，这个查询的作用是：**
找出所有与"高血压"相关的食物，并按"不能吃"、"可以吃"、"推荐吃"这三种分类，分别列出对应的食物清单。

**返回结果示例：**
```
relationship_type | food_names
-----------------|-------------------
"not_eat"        | ["咸菜", "肥肉", "油炸食品"]
"do_eat"         | ["苹果", "香蕉", "蔬菜"]
"recommand_eat"  | ["芹菜", "海带", "燕麦"]
```

这样医生或患者就能一目了然地知道高血压患者应该避免什么食物，可以吃什么，以及推荐吃什么。
2025-12-03 11:39:41,427 - services.graph_service - INFO - 查询验证通过
2025-12-03 11:39:41,440 - services.graph_service - INFO - 收到验证查询请求: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names
2025-12-03 11:39:41,441 - services.graph_service - INFO - 查询验证通过
2025-12-03 11:39:41,446 - services.graph_service - INFO - 收到执行查询请求: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names
2025-12-03 11:39:41,446 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names
2025-12-03 11:39:41,512 - services.graph_service - INFO - 查询执行成功，耗时: 0.066秒，返回 3 条记录
2025-12-03 11:39:41,513 - services.graph_service - INFO - 查询执行完成，返回 3 条记录
2025-12-03 11:40:00,150 - services.graph_service - INFO - 收到生成查询请求: 高血压患者饮食要注意什么？
2025-12-03 11:40:00,233 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 11:40:03,282 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names
2025-12-03 11:40:03,332 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 11:40:17,413 - services.graph_service - INFO - 查询解释: 这个Cypher查询是用来查找与"高血压"相关的食物的，它会返回不同类型的饮食建议以及对应的食物列表。

让我一步步解释：

**查询目的：**
查找高血压患者应该避免、可以吃或推荐吃的食物。

**查询结构：**

1. **`MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food)`**
   - 匹配疾病节点和食物节点之间的关系
   - `d:Disease`：表示疾病节点
   - `f:Food`：表示食物节点
   - `r:not_eat|do_eat|recommand_eat`：匹配三种类型的关系：
     - `not_eat`：不应该吃
     - `do_eat`：可以吃
     - `recommand_eat`：推荐吃

2. **`WHERE d.name = '高血压'`**
   - 只选择疾病名称为"高血压"的节点

3. **`RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names`**
   - 返回结果包含两列：
     - `relationship_type`：关系类型（不应该吃/可以吃/推荐吃）
     - `food_names`：对应的食物名称列表（使用`COLLECT`将多个食物名称收集到一个列表中，`DISTINCT`确保没有重复）

**查询结果示例：**
```
relationship_type | food_names
-----------------|-------------------
"not_eat"        | ["咸菜", "腊肉", "油炸食品"]
"do_eat"         | ["苹果", "香蕉", "全麦面包"]
"recommand_eat"  | ["芹菜", "黑木耳", "燕麦"]
```

简单来说，这个查询就是**找出高血压患者需要避免、可以正常吃和推荐多吃的各种食物**。
2025-12-03 11:40:17,414 - services.graph_service - INFO - 查询验证通过
2025-12-03 11:40:17,419 - services.graph_service - INFO - 收到验证查询请求: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names
2025-12-03 11:40:17,419 - services.graph_service - INFO - 查询验证通过
2025-12-03 11:40:17,423 - services.graph_service - INFO - 收到执行查询请求: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names
2025-12-03 11:40:17,423 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names
2025-12-03 11:40:17,429 - services.graph_service - INFO - 查询执行成功，耗时: 0.006秒，返回 3 条记录
2025-12-03 11:40:17,433 - services.graph_service - INFO - 查询执行完成，返回 3 条记录
2025-12-03 11:41:57,133 - services.graph_service - INFO - 收到生成查询请求: 高血压患者饮食要注意什么？
2025-12-03 11:41:57,321 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 11:42:00,514 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names
2025-12-03 11:42:00,570 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 11:42:14,564 - services.graph_service - INFO - 查询解释: 这个Cypher查询是用来查找与"高血压"相关的食物的，它会返回三种不同类型的食物关系。让我详细解释一下：

**查询的作用：**
查找所有与"高血压"疾病相关的食物，并按关系类型分组返回。

**查询的组成部分：**

1. **`MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food)`**
   - 匹配疾病节点和食物节点之间的三种关系：
     - `not_eat`：不能吃的食物
     - `do_eat`：可以吃的食物  
     - `recommand_eat`：推荐吃的食物
   - `d` 代表疾病节点（标签为 Disease）
   - `f` 代表食物节点（标签为 Food）
   - `r` 代表它们之间的关系

2. **`WHERE d.name = '高血压'`**
   - 筛选条件：只查找名称为"高血压"的疾病

3. **`RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names`**
   - 返回结果包含两列：
     - `relationship_type`：关系类型（不能吃/可以吃/推荐吃）
     - `food_names`：该关系类型下所有食物的名称列表（使用 DISTINCT 去重）

**查询结果示例：**
```
relationship_type | food_names
-----------------|-------------------
"not_eat"        | ["咸菜", "肥肉", "油炸食品"]
"do_eat"         | ["苹果", "香蕉", "芹菜"]
"recommand_eat"  | ["燕麦", "深海鱼", "坚果"]
```

**简单来说：** 这个查询就是找出高血压患者"不能吃"、"可以吃"和"推荐吃"的所有食物，并按这三种分类整理返回。
2025-12-03 11:42:14,565 - services.graph_service - INFO - 查询验证通过
2025-12-03 11:42:14,576 - services.graph_service - INFO - 收到验证查询请求: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names
2025-12-03 11:42:14,576 - services.graph_service - INFO - 查询验证通过
2025-12-03 11:42:14,582 - services.graph_service - INFO - 收到执行查询请求: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names
2025-12-03 11:42:14,583 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names
2025-12-03 11:42:14,629 - services.graph_service - INFO - 查询执行成功，耗时: 0.046秒，返回 3 条记录
2025-12-03 11:42:14,629 - services.graph_service - INFO - 查询执行完成，返回 3 条记录
2025-12-03 11:44:56,679 - services.graph_service - INFO - 收到生成查询请求: 高血压患者饮食要注意什么？
2025-12-03 11:44:56,786 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 11:44:59,627 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names
2025-12-03 11:44:59,734 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 11:45:12,235 - services.graph_service - INFO - 查询解释: 这个Cypher查询是用来查找与"高血压"相关的食物的，它会返回三种不同类型的食物关系。让我详细解释一下：

**查询目的：**
查找与"高血压"疾病相关的所有食物，并按照不同的饮食建议类型进行分类。

**查询分解：**

1. **`MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food)`**
   - 匹配疾病节点和食物节点之间的三种关系：
     - `not_eat`：不能吃的食物
     - `do_eat`：可以吃的食物  
     - `recommand_eat`：推荐吃的食物

2. **`WHERE d.name = '高血压'`**
   - 只查找名为"高血压"的疾病节点

3. **`RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names`**
   - 返回两个结果：
     - `relationship_type`：关系类型（不能吃/可以吃/推荐吃）
     - `food_names`：对应关系下的所有食物名称列表（去重）

**查询结果示例：**
```
relationship_type | food_names
-----------------|-------------------
"not_eat"        | ["咸菜", "肥肉", "油炸食品"]
"do_eat"         | ["苹果", "香蕉", "芹菜"]
"recommand_eat"  | ["燕麦", "深海鱼", "坚果"]
```

**简单来说：**
这个查询就是找出高血压患者"不能吃"、"可以吃"和"推荐吃"的所有食物，并分别列出清单。
2025-12-03 11:45:12,235 - services.graph_service - INFO - 查询验证通过
2025-12-03 11:45:12,244 - services.graph_service - INFO - 收到验证查询请求: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names
2025-12-03 11:45:12,244 - services.graph_service - INFO - 查询验证通过
2025-12-03 11:45:12,250 - services.graph_service - INFO - 收到执行查询请求: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names
2025-12-03 11:45:12,250 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names
2025-12-03 11:45:12,278 - services.graph_service - INFO - 查询执行成功，耗时: 0.028秒，返回 3 条记录
2025-12-03 11:45:12,280 - services.graph_service - INFO - 查询执行完成，返回 3 条记录
2025-12-03 11:53:59,294 - services.graph_service - INFO - 收到生成查询请求: 高血压患者饮食要注意什么？
2025-12-03 11:53:59,389 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 11:54:02,575 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names
2025-12-03 11:54:02,625 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 11:54:16,540 - services.graph_service - INFO - 查询解释: 这个Cypher查询是用来查找与"高血压"相关的食物的，它会返回不同类型的饮食建议以及对应的食物列表。

让我详细解释一下：

**查询目的：**
查找与"高血压"疾病相关的所有食物，并按饮食建议类型分类。

**查询分解：**

1. `MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food)`
   - 匹配疾病节点和食物节点之间的关系
   - `d:Disease`：表示疾病节点，标签为"Disease"
   - `f:Food`：表示食物节点，标签为"Food"
   - `r:not_eat|do_eat|recommand_eat`：表示三种可能的关系类型：
     - `not_eat`：不建议吃
     - `do_eat`：可以吃
     - `recommand_eat`：推荐吃

2. `WHERE d.name = '高血压'`
   - 筛选条件：只查找名称为"高血压"的疾病

3. `RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names`
   - 返回结果：
     - `relationship_type`：关系类型（not_eat/do_eat/recommand_eat）
     - `food_names`：对应关系类型下的所有食物名称列表（使用DISTINCT去重）

**查询结果示例：**
可能会返回类似这样的结果：
- relationship_type: "not_eat", food_names: ["咸菜", "腊肉", "油炸食品"]
- relationship_type: "do_eat", food_names: ["苹果", "香蕉", "全麦面包"]
- relationship_type: "recommand_eat", food_names: ["芹菜", "海带", "燕麦"]

**简单来说：**
这个查询就是找出高血压患者"不能吃"、"可以吃"和"推荐吃"的所有食物，并按这三种分类整理出来。
2025-12-03 11:54:16,541 - services.graph_service - INFO - 查询验证通过
2025-12-03 11:54:16,549 - services.graph_service - INFO - 收到验证查询请求: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names
2025-12-03 11:54:16,549 - services.graph_service - INFO - 查询验证通过
2025-12-03 11:54:16,554 - services.graph_service - INFO - 收到执行查询请求: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names
2025-12-03 11:54:16,554 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names
2025-12-03 11:54:16,606 - services.graph_service - INFO - 查询执行成功，耗时: 0.051秒，返回 3 条记录
2025-12-03 11:54:16,606 - services.graph_service - INFO - 查询执行完成，返回 3 条记录
2025-12-03 11:57:25,083 - services.graph_service - INFO - 收到生成查询请求: 高血压患者饮食要注意什么？
2025-12-03 11:57:25,226 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 11:57:28,213 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names
2025-12-03 11:57:28,272 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 11:57:42,592 - services.graph_service - INFO - 查询解释: 这个Cypher查询是用来查找与"高血压"相关的食物信息。让我一步步解释：

## 查询目的
找出与"高血压"疾病相关的所有食物，并按关系类型分类。

## 各部分解释：

1. **`MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food)`**
   - 匹配疾病节点和食物节点之间的三种关系：
     - `not_eat`：不能吃的食物
     - `do_eat`：可以吃的食物  
     - `recommand_eat`：推荐吃的食物
   - `d`：代表疾病节点（标签为Disease）
   - `f`：代表食物节点（标签为Food）
   - `r`：代表关系

2. **`WHERE d.name = '高血压'`**
   - 筛选条件：只查找名为"高血压"的疾病

3. **`RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names`**
   - 返回结果包含两列：
     - `relationship_type`：关系类型（不能吃/可以吃/推荐吃）
     - `food_names`：对应关系下的所有食物名称列表
   - `COLLECT(DISTINCT f.name)`：将食物名称收集成列表，并去重

## 查询结果示例：
```
relationship_type | food_names
-----------------|-------------------
"not_eat"        | ["咸菜", "腊肉", "油炸食品"]
"do_eat"         | ["苹果", "香蕉", "蔬菜"]
"recommand_eat"  | ["燕麦", "深海鱼", "坚果"]
```

## 简单来说：
这个查询就是**找出高血压患者不能吃、可以吃和推荐吃的所有食物，并按这三种分类分别列出**。
2025-12-03 11:57:42,592 - services.graph_service - INFO - 查询验证通过
2025-12-03 11:57:42,599 - services.graph_service - INFO - 收到验证查询请求: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names
2025-12-03 11:57:42,599 - services.graph_service - INFO - 查询验证通过
2025-12-03 11:57:42,603 - services.graph_service - INFO - 收到执行查询请求: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names
2025-12-03 11:57:42,603 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names
2025-12-03 11:57:42,610 - services.graph_service - INFO - 查询执行成功，耗时: 0.007秒，返回 3 条记录
2025-12-03 11:57:42,610 - services.graph_service - INFO - 查询执行完成，返回 3 条记录
2025-12-03 11:57:47,742 - services.graph_service - INFO - 收到执行查询请求: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names
2025-12-03 11:57:47,743 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names
2025-12-03 11:57:47,785 - services.graph_service - INFO - 查询执行成功，耗时: 0.042秒，返回 3 条记录
2025-12-03 11:57:47,785 - services.graph_service - INFO - 查询执行完成，返回 3 条记录
2025-12-03 11:59:05,308 - services.graph_service - INFO - 收到生成查询请求: 高血压患者饮食要注意什么？
2025-12-03 11:59:05,432 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 11:59:08,070 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, f.name AS food_name
2025-12-03 11:59:08,122 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 11:59:20,763 - services.graph_service - INFO - 查询解释: 这个Cypher查询用于在Neo4j图数据库中查找与"高血压"相关的食物信息。让我详细解释一下：

## 查询的作用：
查找所有与"高血压"疾病相关的食物，并显示它们之间的关系类型和食物名称。

## 各部分解释：

1. **`MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food)`**
   - 匹配疾病节点和食物节点之间的三种关系：
     - `not_eat`：不能吃的食物
     - `do_eat`：可以吃的食物  
     - `recommand_eat`：推荐吃的食物
   - `d`：代表疾病节点（标签为Disease）
   - `f`：代表食物节点（标签为Food）
   - `r`：代表关系变量

2. **`WHERE d.name = '高血压'`**
   - 筛选条件：只查找名称为"高血压"的疾病

3. **`RETURN type(r) AS relationship_type, f.name AS food_name`**
   - 返回结果包含两列：
     - `relationship_type`：关系类型（不能吃/可以吃/推荐吃）
     - `food_name`：食物名称

## 查询结果示例：
```
relationship_type | food_name
-----------------|-----------
not_eat          | 咸菜
do_eat           | 苹果
recommand_eat    | 芹菜
```

## 简单来说：
这个查询就是**找出所有与高血压相关的食物，并告诉我们每种食物是高血压患者不能吃、可以吃还是推荐吃的**。
2025-12-03 11:59:20,764 - services.graph_service - INFO - 查询验证通过
2025-12-03 11:59:20,769 - services.graph_service - INFO - 收到验证查询请求: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, f.name AS food_name
2025-12-03 11:59:20,769 - services.graph_service - INFO - 查询验证通过
2025-12-03 11:59:20,772 - services.graph_service - INFO - 收到执行查询请求: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, f.name AS food_name
2025-12-03 11:59:20,772 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, f.name AS food_name
2025-12-03 11:59:20,784 - services.graph_service - INFO - 查询执行成功，耗时: 0.012秒，返回 15 条记录
2025-12-03 11:59:20,785 - services.graph_service - INFO - 查询执行完成，返回 15 条记录
2025-12-03 11:59:25,736 - services.graph_service - INFO - 收到执行查询请求: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, f.name AS food_name
2025-12-03 11:59:25,736 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, f.name AS food_name
2025-12-03 11:59:25,741 - services.graph_service - INFO - 查询执行成功，耗时: 0.005秒，返回 15 条记录
2025-12-03 11:59:25,741 - services.graph_service - INFO - 查询执行完成，返回 15 条记录
2025-12-03 12:02:32,676 - services.graph_service - INFO - 收到生成查询请求: 高血压患者饮食要注意什么？
2025-12-03 12:02:32,764 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 12:02:35,356 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names
2025-12-03 12:02:35,394 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 12:02:48,750 - services.graph_service - INFO - 查询解释: 这个Cypher查询是用来查找与"高血压"相关的食物的，它会返回不同类型的饮食建议以及对应的食物列表。

让我详细解释一下：

**查询目的：**
查找高血压患者应该避免、可以吃或推荐吃的食物。

**查询结构：**

1. **`MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food)`**
   - 匹配疾病节点和食物节点之间的关系
   - `d:Disease`：表示疾病节点
   - `f:Food`：表示食物节点
   - `r:not_eat|do_eat|recommand_eat`：表示三种关系类型中的任意一种：
     - `not_eat`：不应该吃
     - `do_eat`：可以吃
     - `recommand_eat`：推荐吃

2. **`WHERE d.name = '高血压'`**
   - 只查找疾病名称为"高血压"的记录

3. **`RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names`**
   - 返回两个结果：
     - `relationship_type`：关系类型（不应该吃/可以吃/推荐吃）
     - `food_names`：对应关系下的所有食物名称（使用`DISTINCT`去重，`COLLECT`将结果收集为列表）

**查询结果示例：**
```
relationship_type | food_names
-----------------|-------------------
"not_eat"        | ["咸菜", "腊肉", "油炸食品"]
"do_eat"         | ["苹果", "香蕉", "全麦面包"]
"recommand_eat"  | ["芹菜", "海带", "燕麦"]
```

简单来说，这个查询就是**找出高血压患者需要避免、可以正常吃和推荐多吃的所有食物，并按类别分组显示**。
2025-12-03 12:02:48,751 - services.graph_service - INFO - 查询验证通过
2025-12-03 12:02:48,759 - services.graph_service - INFO - 收到验证查询请求: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names
2025-12-03 12:02:48,759 - services.graph_service - INFO - 查询验证通过
2025-12-03 12:02:48,769 - services.graph_service - INFO - 收到执行查询请求: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names
2025-12-03 12:02:48,769 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names
2025-12-03 12:02:48,782 - services.graph_service - INFO - 查询执行成功，耗时: 0.012秒，返回 3 条记录
2025-12-03 12:02:48,784 - services.graph_service - INFO - 查询执行完成，返回 3 条记录
2025-12-03 12:02:53,374 - services.graph_service - INFO - 收到执行查询请求: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names
2025-12-03 12:02:53,375 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names
2025-12-03 12:02:53,380 - services.graph_service - INFO - 查询执行成功，耗时: 0.006秒，返回 3 条记录
2025-12-03 12:02:53,381 - services.graph_service - INFO - 查询执行完成，返回 3 条记录
2025-12-03 12:06:11,740 - services.graph_service - INFO - 收到生成查询请求: 高血压患者饮食要注意什么？
2025-12-03 12:06:11,838 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 12:06:15,211 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS foods
2025-12-03 12:06:15,278 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 12:06:28,733 - services.graph_service - INFO - 查询解释: 这个Cypher查询是用来查找与"高血压"相关的食物的，它会返回不同类型的饮食建议以及对应的食物列表。

让我详细解释一下：

**查询目的：**
查找高血压患者应该避免、可以吃或推荐吃的食物

**查询结构：**

1. **`MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food)`**
   - 匹配疾病节点和食物节点之间的关系
   - `d:Disease`：表示疾病节点，标签是"Disease"
   - `f:Food`：表示食物节点，标签是"Food"
   - `[r:not_eat|do_eat|recommand_eat]`：匹配三种类型的关系：
     - `not_eat`：不应该吃的食物
     - `do_eat`：可以吃的食物  
     - `recommand_eat`：推荐吃的食物

2. **`WHERE d.name = '高血压'`**
   - 筛选条件：只查找名称为"高血压"的疾病

3. **`RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS foods`**
   - 返回结果：
     - `relationship_type`：关系类型（not_eat、do_eat或recommand_eat）
     - `foods`：对应关系类型下的所有食物名称列表（使用DISTINCT去重）

**查询结果示例：**
可能会返回类似这样的结果：
```
relationship_type | foods
-----------------|-------------------
not_eat          | ["咸菜", "腊肉", "油炸食品"]
do_eat           | ["苹果", "香蕉", "全麦面包"]
recommand_eat    | ["芹菜", "海带", "黑木耳"]
```

简单来说，这个查询就是**找出高血压患者需要避免、可以吃和推荐吃的各种食物**。
2025-12-03 12:06:28,734 - services.graph_service - INFO - 查询验证通过
2025-12-03 12:06:28,744 - services.graph_service - INFO - 收到验证查询请求: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS foods
2025-12-03 12:06:28,744 - services.graph_service - INFO - 查询验证通过
2025-12-03 12:06:28,749 - services.graph_service - INFO - 收到执行查询请求: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS foods
2025-12-03 12:06:28,750 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS foods
2025-12-03 12:06:28,832 - services.graph_service - INFO - 查询执行成功，耗时: 0.082秒，返回 3 条记录
2025-12-03 12:06:28,832 - services.graph_service - INFO - 查询执行完成，返回 3 条记录
2025-12-03 12:06:33,369 - services.graph_service - INFO - 收到执行查询请求: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS foods
2025-12-03 12:06:33,370 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS foods
2025-12-03 12:06:33,383 - services.graph_service - INFO - 查询执行成功，耗时: 0.013秒，返回 3 条记录
2025-12-03 12:06:33,383 - services.graph_service - INFO - 查询执行完成，返回 3 条记录
2025-12-03 12:12:07,085 - services.graph_service - INFO - 收到生成查询请求: 高血压患者饮食要注意什么？
2025-12-03 12:12:07,198 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 12:12:10,176 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names
2025-12-03 12:12:10,212 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 12:12:25,216 - services.graph_service - INFO - 查询解释: 这个Cypher查询是用来查找与"高血压"相关的食物的，它会返回不同类型的饮食建议以及对应的食物列表。

让我详细解释一下：

**查询目的：**
查找与"高血压"疾病相关的所有食物，并按饮食建议类型分类。

**查询分解：**

1. **`MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food)`**
   - 匹配疾病节点和食物节点之间的关系
   - `d:Disease`：表示疾病节点，标签是"Disease"
   - `f:Food`：表示食物节点，标签是"Food"
   - `[r:not_eat|do_eat|recommand_eat]`：匹配三种类型的关系：
     - `not_eat`：不建议吃
     - `do_eat`：可以吃
     - `recommand_eat`：推荐吃

2. **`WHERE d.name = '高血压'`**
   - 筛选条件：只查找疾病名称为"高血压"的记录

3. **`RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names`**
   - 返回结果包含两列：
     - `relationship_type`：关系类型（not_eat、do_eat或recommand_eat）
     - `food_names`：对应关系类型下的所有食物名称列表（使用`DISTINCT`去重）

**查询结果示例：**
```
relationship_type | food_names
-----------------|-------------------
"not_eat"        | ["咸菜", "腊肉", "油炸食品"]
"do_eat"         | ["苹果", "香蕉", "全麦面包"]
"recommand_eat"  | ["芹菜", "黑木耳", "海带"]
```

**简单来说：**
这个查询就是找出高血压患者"不建议吃"、"可以吃"和"推荐吃"的所有食物，并按这三种分类分别列出对应的食物清单。
2025-12-03 12:12:25,217 - services.graph_service - INFO - 查询验证通过
2025-12-03 12:12:25,225 - services.graph_service - INFO - 收到验证查询请求: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names
2025-12-03 12:12:25,225 - services.graph_service - INFO - 查询验证通过
2025-12-03 12:12:25,231 - services.graph_service - INFO - 收到执行查询请求: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names
2025-12-03 12:12:25,231 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names
2025-12-03 12:12:25,248 - services.graph_service - INFO - 查询执行成功，耗时: 0.017秒，返回 3 条记录
2025-12-03 12:12:25,248 - services.graph_service - INFO - 查询执行完成，返回 3 条记录
2025-12-03 12:13:17,198 - services.graph_service - INFO - 收到生成查询请求: 感冒了有什么症状？
2025-12-03 12:13:17,282 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 12:13:19,685 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (d:Disease)-[:has_symptom]->(s:Symptom) 
WHERE d.name = '感冒' 
RETURN s.name
2025-12-03 12:13:19,725 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 12:13:30,720 - services.graph_service - INFO - 查询解释: 这个Cypher查询的作用是：**查找与"感冒"相关的所有症状名称**。

让我详细解释一下：

## 查询结构解析：

1. **`MATCH (d:Disease)-[:has_symptom]->(s:Symptom)`**
   - 匹配图数据库中的模式：找到所有标签为"Disease"的节点（用`d`表示），这些节点通过"has_symptom"关系指向标签为"Symptom"的节点（用`s`表示）
   - 这表示"疾病有症状"的关系

2. **`WHERE d.name = '感冒'`**
   - 筛选条件：只选择疾病名称为"感冒"的节点

3. **`RETURN s.name`**
   - 返回结果：只返回症状节点的名称

## 通俗理解：
想象一个医疗知识图谱：
- 有一个"感冒"节点（疾病）
- 这个节点连接着多个症状节点，比如"发烧"、"咳嗽"、"流鼻涕"等
- 这个查询就是找出所有与"感冒"直接相关的症状名称

## 查询结果：
会返回一个列表，包含所有感冒的症状名称，例如：
- 发烧
- 咳嗽
- 流鼻涕
- 头痛
- ...等等

这个查询在医疗诊断系统、症状查询应用等场景中非常有用。
2025-12-03 12:13:30,721 - services.graph_service - INFO - 查询验证通过
2025-12-03 12:13:30,728 - services.graph_service - INFO - 收到验证查询请求: MATCH (d:Disease)-[:has_symptom]->(s:Symptom) 
WHERE d.name = '感冒' 
RETURN s.name
2025-12-03 12:13:30,729 - services.graph_service - INFO - 查询验证通过
2025-12-03 12:13:30,735 - services.graph_service - INFO - 收到执行查询请求: MATCH (d:Disease)-[:has_symptom]->(s:Symptom) 
WHERE d.name = '感冒' 
RETURN s.name
2025-12-03 12:13:30,735 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (d:Disease)-[:has_symptom]->(s:Symptom) 
WHERE d.name = '感冒' 
RETURN s.name
2025-12-03 12:13:30,754 - services.graph_service - INFO - 查询执行成功，耗时: 0.019秒，返回 9 条记录
2025-12-03 12:13:30,755 - services.graph_service - INFO - 查询执行完成，返回 9 条记录
2025-12-03 12:14:33,067 - services.graph_service - INFO - 收到生成查询请求: 糖尿病患者可以吃哪些水果？
2025-12-03 12:14:33,188 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 12:14:35,554 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (d:Disease)-[:do_eat]-(f:Food) 
WHERE d.name = '糖尿病' 
RETURN f.name
2025-12-03 12:14:35,592 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 12:14:47,036 - services.graph_service - INFO - 查询解释: 这个Cypher查询是用来在Neo4j图数据库中查找与"糖尿病"相关的食物的。让我一步步解释：

**查询目的：**
找到适合糖尿病患者食用的食物。

**查询结构：**

1. **`MATCH (d:Disease)-[:do_eat]-(f:Food)`**
   - 匹配图数据库中的模式
   - `d:Disease`：查找标签为"Disease"的节点，给它起个别名"d"
   - `f:Food`：查找标签为"Food"的节点，给它起个别名"f"
   - `-[:do_eat]-`：查找这两个节点之间通过"do_eat"关系连接
   - 这个关系表示"可以吃"或"适合食用"

2. **`WHERE d.name = '糖尿病'`**
   - 筛选条件：只选择疾病名称为"糖尿病"的节点

3. **`RETURN f.name`**
   - 返回结果：只返回食物节点的名称

**简单来说：**
这个查询的意思是："在数据库中找出所有与'糖尿病'节点通过'do_eat'关系连接的食物节点，并返回这些食物的名称。"

**实际应用场景：**
这可能是医疗或营养健康应用中的一部分，用于为糖尿病患者推荐合适的食物。数据库可能存储了各种疾病与食物之间的营养关系，这个查询专门提取适合糖尿病患者食用的食物列表。
2025-12-03 12:14:47,037 - services.graph_service - INFO - 查询验证通过
2025-12-03 12:14:47,045 - services.graph_service - INFO - 收到验证查询请求: MATCH (d:Disease)-[:do_eat]-(f:Food) 
WHERE d.name = '糖尿病' 
RETURN f.name
2025-12-03 12:14:47,046 - services.graph_service - INFO - 查询验证通过
2025-12-03 12:14:47,052 - services.graph_service - INFO - 收到执行查询请求: MATCH (d:Disease)-[:do_eat]-(f:Food) 
WHERE d.name = '糖尿病' 
RETURN f.name
2025-12-03 12:14:47,052 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (d:Disease)-[:do_eat]-(f:Food) 
WHERE d.name = '糖尿病' 
RETURN f.name
2025-12-03 12:14:47,093 - services.graph_service - INFO - 查询执行成功，耗时: 0.041秒，返回 0 条记录
2025-12-03 12:14:47,093 - services.graph_service - INFO - 查询执行完成，返回 0 条记录
2025-12-03 12:15:34,868 - services.graph_service - INFO - 收到生成查询请求: 失眠有什么好的治疗方法？
2025-12-03 12:15:34,972 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 12:15:37,540 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (d:Disease)-[r:recommand_drug|command_drug]-(drug:Drug) 
WHERE d.name = '失眠' 
RETURN COLLECT(DISTINCT drug.name) AS recommended_drugs
2025-12-03 12:15:37,730 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 12:15:52,837 - services.graph_service - INFO - 查询解释: 这个Cypher查询的作用是**查找与"失眠"相关的推荐药物**。

让我一步步解释：

## 查询的核心目的
找出所有与"失眠"疾病相关的药物名称。

## 查询分解：

1. **`MATCH (d:Disease)-[r:recommand_drug|command_drug]-(drug:Drug)`**
   - 匹配疾病节点和药物节点之间的关系
   - `d:Disease`：标签为"Disease"的节点（代表疾病）
   - `drug:Drug`：标签为"Drug"的节点（代表药物）
   - `[r:recommand_drug|command_drug]`：两种可能的关系类型
     - `recommand_drug`（可能是"recommend_drug"的拼写错误）
     - `command_drug`

2. **`WHERE d.name = '失眠'`**
   - 筛选条件：只找名称为"失眠"的疾病节点

3. **`RETURN COLLECT(DISTINCT drug.name) AS recommended_drugs`**
   - 返回结果：收集所有不重复的药物名称
   - `DISTINCT`：去除重复的药物名称
   - `COLLECT()`：将多个结果合并成一个列表
   - 结果命名为`recommended_drugs`

## 简单来说：
**"在知识图谱中，找到所有与'失眠'疾病有推荐关系的药物，并把它们的名字整理成一个不重复的列表返回。"**

## 预期结果：
会返回一个类似这样的结果：
```
recommended_drugs: ["安眠药A", "镇静剂B", "中药C", ...]
```

## 注意：
查询中可能存在拼写问题：
- `recommand_drug` 可能是 `recommend_drug`（推荐药物关系）
- `command_drug` 可能是某种特定的药物关系类型

这个查询在医疗知识图谱或药物推荐系统中很常见，用于根据疾病查找相关药物。
2025-12-03 12:15:52,838 - services.graph_service - INFO - 查询验证通过
2025-12-03 12:15:52,844 - services.graph_service - INFO - 收到验证查询请求: MATCH (d:Disease)-[r:recommand_drug|command_drug]-(drug:Drug) 
WHERE d.name = '失眠' 
RETURN COLLECT(DISTINCT drug.name) AS recommended_drugs
2025-12-03 12:15:52,844 - services.graph_service - INFO - 查询验证通过
2025-12-03 12:15:52,846 - services.graph_service - INFO - 收到执行查询请求: MATCH (d:Disease)-[r:recommand_drug|command_drug]-(drug:Drug) 
WHERE d.name = '失眠' 
RETURN COLLECT(DISTINCT drug.name) AS recommended_drugs
2025-12-03 12:15:52,846 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (d:Disease)-[r:recommand_drug|command_drug]-(drug:Drug) 
WHERE d.name = '失眠' 
RETURN COLLECT(DISTINCT drug.name) AS recommended_drugs
2025-12-03 12:15:52,888 - services.graph_service - INFO - 查询执行成功，耗时: 0.042秒，返回 1 条记录
2025-12-03 12:15:52,888 - services.graph_service - INFO - 查询执行完成，返回 1 条记录
2025-12-03 12:18:51,352 - services.graph_service - INFO - 收到生成查询请求: 保和丸能治疗什么疾病？
2025-12-03 12:18:51,441 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 12:18:53,867 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (d:Drug)-[:recommand_drug|command_drug]-(dis:Disease) 
WHERE d.name = '保和丸' 
RETURN DISTINCT dis.name AS disease_name
2025-12-03 12:18:53,909 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 12:19:05,743 - services.graph_service - INFO - 查询解释: 这个Cypher查询的作用是**查找与"保和丸"相关的疾病**。

让我详细解释一下：

## 查询的组成部分：

1. **`MATCH (d:Drug)-[:recommand_drug|command_drug]-(dis:Disease)`**
   - 查找所有"药品"节点（标签为`Drug`）和"疾病"节点（标签为`Disease`）
   - 这些节点通过两种类型的关系连接：`recommand_drug` 或 `command_drug`
   - `d` 代表药品节点，`dis` 代表疾病节点

2. **`WHERE d.name = '保和丸'`**
   - 只选择名称为"保和丸"的药品节点

3. **`RETURN DISTINCT dis.name AS disease_name`**
   - 返回所有与"保和丸"相关的疾病名称
   - `DISTINCT` 确保相同的疾病名称只出现一次（去重）
   - 将结果命名为 `disease_name`

## 简单来说：
这个查询的意思是：**"找出所有与'保和丸'药品有推荐或命令关系的疾病名称"**

## 实际应用场景：
在医疗知识图谱中，这个查询可以用来：
- 了解"保和丸"这个药物可以治疗或推荐用于哪些疾病
- 获取药物的适应症信息
- 药物与疾病的关系分析

查询结果会返回一个疾病名称的列表，这些疾病都与"保和丸"有某种推荐或命令关系。
2025-12-03 12:19:05,745 - services.graph_service - INFO - 查询验证通过
2025-12-03 12:19:05,753 - services.graph_service - INFO - 收到验证查询请求: MATCH (d:Drug)-[:recommand_drug|command_drug]-(dis:Disease) 
WHERE d.name = '保和丸' 
RETURN DISTINCT dis.name AS disease_name
2025-12-03 12:19:05,754 - services.graph_service - INFO - 查询验证通过
2025-12-03 12:19:05,759 - services.graph_service - INFO - 收到执行查询请求: MATCH (d:Drug)-[:recommand_drug|command_drug]-(dis:Disease) 
WHERE d.name = '保和丸' 
RETURN DISTINCT dis.name AS disease_name
2025-12-03 12:19:05,759 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (d:Drug)-[:recommand_drug|command_drug]-(dis:Disease) 
WHERE d.name = '保和丸' 
RETURN DISTINCT dis.name AS disease_name
2025-12-03 12:19:05,803 - services.graph_service - INFO - 查询执行成功，耗时: 0.044秒，返回 6 条记录
2025-12-03 12:19:05,804 - services.graph_service - INFO - 查询执行完成，返回 6 条记录
2025-12-03 12:25:18,885 - services.graph_service - INFO - 收到生成查询请求: 肩痛应该怎么治疗？
2025-12-03 12:25:18,994 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 12:25:21,781 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (d:Disease)-[:has_symptom]->(s:Symptom)
WHERE s.name CONTAINS '肩痛'
RETURN d.name AS disease_name, d.cure_way AS treatment_method
2025-12-03 12:25:21,829 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 12:25:35,011 - services.graph_service - INFO - 查询解释: 这个Cypher查询是用来从Neo4j图数据库中查找与"肩痛"相关的疾病信息的。让我一步步解释：

## 查询的作用：
查找所有**包含"肩痛"症状的疾病**，并返回这些疾病的名称和治疗方法。

## 各部分解释：

1. **`MATCH (d:Disease)-[:has_symptom]->(s:Symptom)`**
   - 匹配图数据库中的模式：找到所有"疾病"节点（标签为Disease）通过"has_symptom"关系连接到"症状"节点（标签为Symptom）
   - `d` 代表疾病节点
   - `s` 代表症状节点

2. **`WHERE s.name CONTAINS '肩痛'`**
   - 筛选条件：只选择症状名称中包含"肩痛"的症状
   - 比如"肩痛"、"左肩痛"、"肩痛伴活动受限"等都会被匹配

3. **`RETURN d.name AS disease_name, d.cure_way AS treatment_method`**
   - 返回结果：显示疾病名称和治疗方法
   - 给返回的列起了别名，让结果更易读

## 简单来说：
这个查询相当于问："哪些疾病会有肩痛的症状？这些疾病分别怎么治疗？"

## 可能的查询结果示例：
```
disease_name       | treatment_method
-------------------|------------------
肩周炎            | 物理治疗、药物治疗
颈椎病            | 牵引、理疗
肩袖损伤          | 休息、手术
...               | ...
```

这个查询在医疗知识图谱、症状自查系统等场景中非常有用。
2025-12-03 12:25:35,012 - services.graph_service - INFO - 查询验证通过
2025-12-03 12:25:35,021 - services.graph_service - INFO - 收到验证查询请求: MATCH (d:Disease)-[:has_symptom]->(s:Symptom)
WHERE s.name CONTAINS '肩痛'
RETURN d.name AS disease_name, d.cure_way AS treatment_method
2025-12-03 12:25:35,021 - services.graph_service - INFO - 查询验证通过
2025-12-03 12:25:35,026 - services.graph_service - INFO - 收到执行查询请求: MATCH (d:Disease)-[:has_symptom]->(s:Symptom)
WHERE s.name CONTAINS '肩痛'
RETURN d.name AS disease_name, d.cure_way AS treatment_method
2025-12-03 12:25:35,026 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (d:Disease)-[:has_symptom]->(s:Symptom)
WHERE s.name CONTAINS '肩痛'
RETURN d.name AS disease_name, d.cure_way AS treatment_method
2025-12-03 12:25:35,071 - services.graph_service - INFO - 查询执行成功，耗时: 0.044秒，返回 1 条记录
2025-12-03 12:25:35,071 - services.graph_service - INFO - 查询执行完成，返回 1 条记录
2025-12-03 13:09:24,707 - services.graph_service - INFO - 收到生成查询请求: 高血压患者饮食要注意什么？
2025-12-03 13:09:24,817 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 13:09:27,995 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names
2025-12-03 13:09:28,041 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 13:09:42,196 - services.graph_service - INFO - 查询解释: 这个Cypher查询是用来查找与"高血压"相关的食物的，它会返回三种不同类型的食物关系。让我详细解释一下：

**查询目的：**
查找与"高血压"疾病相关的所有食物，并按照不同的饮食建议类型进行分类。

**查询分解：**

1. **`MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food)`**
   - 匹配疾病节点和食物节点之间的三种关系：
     - `not_eat`：不能吃的食物
     - `do_eat`：可以吃的食物  
     - `recommand_eat`：推荐吃的食物
   - `d` 代表疾病节点（标签为 Disease）
   - `f` 代表食物节点（标签为 Food）
   - `r` 代表它们之间的关系

2. **`WHERE d.name = '高血压'`**
   - 只查找名称为"高血压"的疾病

3. **`RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names`**
   - 返回两个结果：
     - `relationship_type`：关系类型（not_eat、do_eat或recommand_eat）
     - `food_names`：对应关系类型下的所有食物名称列表（使用DISTINCT去重）

**查询结果示例：**
```
relationship_type | food_names
-----------------|-------------------
"not_eat"        | ["咸菜", "腊肉", "油炸食品"]
"do_eat"         | ["苹果", "香蕉", "芹菜"]
"recommand_eat"  | ["燕麦", "深海鱼", "坚果"]
```

**简单来说：** 这个查询就是找出高血压患者"不能吃"、"可以吃"和"推荐吃"的所有食物，并按这三种分类整理出来。
2025-12-03 13:09:42,197 - services.graph_service - INFO - 查询验证通过
2025-12-03 13:09:42,206 - services.graph_service - INFO - 收到验证查询请求: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names
2025-12-03 13:09:42,206 - services.graph_service - INFO - 查询验证通过
2025-12-03 13:09:42,211 - services.graph_service - INFO - 收到执行查询请求: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names
2025-12-03 13:09:42,211 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name = '高血压' 
RETURN type(r) AS relationship_type, COLLECT(DISTINCT f.name) AS food_names
2025-12-03 13:09:42,241 - services.graph_service - INFO - 查询执行成功，耗时: 0.030秒，返回 3 条记录
2025-12-03 13:09:42,241 - services.graph_service - INFO - 查询执行完成，返回 3 条记录
2025-12-03 13:48:26,215 - services.graph_service - INFO - 收到生成查询请求: 小腿酸痛怎么治疗
2025-12-03 13:48:26,336 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 13:48:29,139 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (d:Disease)-[:has_symptom]->(s:Symptom)
WHERE s.name CONTAINS '小腿酸痛'
RETURN d.name AS disease_name, d.cure_way AS treatment_method
2025-12-03 13:48:29,181 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 13:48:45,549 - services.graph_service - INFO - 查询解释: 这个Cypher查询用于从Neo4j图数据库中查找与特定症状相关的疾病信息。让我详细解释一下：

## 查询功能
这个查询的目的是：**找出所有可能导致"小腿酸痛"症状的疾病及其治疗方法**。

## 各部分解释：

1. **`MATCH (d:Disease)-[:has_symptom]->(s:Symptom)`**
   - 匹配图数据库中的模式
   - `d:Disease`：查找标签为"Disease"的节点，并给它们起别名"d"
   - `s:Symptom`：查找标签为"Symptom"的节点，并给它们起别名"s"
   - `-[:has_symptom]->`：查找从疾病节点指向症状节点的"has_symptom"关系
   - 整体意思是：找到所有与症状有"has_symptom"关系的疾病

2. **`WHERE s.name CONTAINS '小腿酸痛'`**
   - 筛选条件：只选择症状名称中包含"小腿酸痛"的症状节点
   - `CONTAINS`是部分匹配，所以也会匹配"左小腿酸痛"、"右小腿酸痛"等

3. **`RETURN d.name AS disease_name, d.cure_way AS treatment_method`**
   - 返回结果：显示疾病名称和治疗方法
   - `d.name`：疾病的名称
   - `d.cure_way`：疾病的治疗方式
   - `AS`：给返回的列起别名，让结果更易读

## 实际应用场景
假设你有一个医疗知识图谱数据库，这个查询可以帮助：
- 医生根据症状快速查找可能的疾病
- 患者自我诊断时了解可能的病因
- 医疗系统构建症状-疾病关联查询

## 查询结果示例
可能会返回类似这样的结果：
```
disease_name        | treatment_method
-------------------|------------------
肌肉拉伤           | 休息、冷敷、物理治疗
静脉曲张           | 药物治疗、手术
骨质疏松           | 补钙、药物治疗
```

简单说：**这个查询就是"告诉我哪些疾病会引起小腿酸痛，以及这些疾病怎么治疗"**。
2025-12-03 13:48:45,550 - services.graph_service - INFO - 查询验证通过
2025-12-03 13:48:45,561 - services.graph_service - INFO - 收到验证查询请求: MATCH (d:Disease)-[:has_symptom]->(s:Symptom)
WHERE s.name CONTAINS '小腿酸痛'
RETURN d.name AS disease_name, d.cure_way AS treatment_method
2025-12-03 13:48:45,561 - services.graph_service - INFO - 查询验证通过
2025-12-03 13:48:45,568 - services.graph_service - INFO - 收到执行查询请求: MATCH (d:Disease)-[:has_symptom]->(s:Symptom)
WHERE s.name CONTAINS '小腿酸痛'
RETURN d.name AS disease_name, d.cure_way AS treatment_method
2025-12-03 13:48:45,568 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (d:Disease)-[:has_symptom]->(s:Symptom)
WHERE s.name CONTAINS '小腿酸痛'
RETURN d.name AS disease_name, d.cure_way AS treatment_method
2025-12-03 13:48:45,623 - services.graph_service - INFO - 查询执行成功，耗时: 0.054秒，返回 1 条记录
2025-12-03 13:48:45,623 - services.graph_service - INFO - 查询执行完成，返回 1 条记录
2025-12-03 13:51:20,661 - services.graph_service - INFO - 收到生成查询请求: 肩痛可以吃什么药物进行治疗，我现在可以去什么科室检查，有什么忌口吗
2025-12-03 13:51:20,772 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 13:51:26,137 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (d:Disease {name: '肩痛'})
OPTIONAL MATCH (d)-[:recommand_drug|command_drug]-(drug:Drug)
OPTIONAL MATCH (d)-[:belongs_to]-(dept:Department)
OPTIONAL MATCH (d)-[:not_eat]-(food:Food)
RETURN 
  COLLECT(DISTINCT drug.name) AS recommended_drugs,
  COLLECT(DISTINCT dept.name) AS departments,
  COLLECT(DISTINCT food.name) AS avoid_foods
2025-12-03 13:51:26,182 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 13:51:47,782 - services.graph_service - INFO - 查询解释: 这个Cypher查询用于从Neo4j图数据库中查找与"肩痛"疾病相关的信息。让我一步步解释：

## 查询目的
查找名为"肩痛"的疾病，并获取：
1. 推荐药物
2. 所属科室
3. 需要避免的食物

## 查询分解

### 1. 主匹配
```cypher
MATCH (d:Disease {name: '肩痛'})
```
- 查找标签为`Disease`的节点
- 节点属性`name`必须等于"肩痛"
- 将找到的节点赋值给变量`d`

### 2. 可选匹配1 - 药物
```cypher
OPTIONAL MATCH (d)-[:recommand_drug|command_drug]-(drug:Drug)
```
- 查找与疾病节点`d`相连的药物节点
- 通过两种关系类型连接：`recommand_drug`或`command_drug`
- 找到的药物节点标签为`Drug`，赋值给变量`drug`
- `OPTIONAL`表示即使没有匹配的药物，查询也会继续执行

### 3. 可选匹配2 - 科室
```cypher
OPTIONAL MATCH (d)-[:belongs_to]-(dept:Department)
```
- 查找疾病所属的科室
- 通过`belongs_to`关系连接
- 科室节点标签为`Department`，赋值给变量`dept`

### 4. 可选匹配3 - 食物
```cypher
OPTIONAL MATCH (d)-[:not_eat]-(food:Food)
```
- 查找疾病需要避免的食物
- 通过`not_eat`关系连接
- 食物节点标签为`Food`，赋值给变量`food`

### 5. 返回结果
```cypher
RETURN 
  COLLECT(DISTINCT drug.name) AS recommended_drugs,
  COLLECT(DISTINCT dept.name) AS departments,
  COLLECT(DISTINCT food.name) AS avoid_foods
```
- `COLLECT()`：将多个值收集到一个列表中
- `DISTINCT`：去除重复值
- 返回三个列表：
  - `recommended_drugs`：推荐药物名称列表
  - `departments`：所属科室名称列表
  - `avoid_foods`：需要避免的食物名称列表

## 查询结果示例
查询可能返回类似这样的结果：
```
{
  "recommended_drugs": ["布洛芬", "双氯芬酸钠"],
  "departments": ["骨科", "康复科"],
  "avoid_foods": ["辛辣食物", "海鲜"]
}
```

## 特点说明
- 所有匹配都是`OPTIONAL`，意味着即使某些信息不存在，查询也会返回结果（对应字段为空列表）
- 使用`|`符号表示"或"关系，可以匹配多种关系类型
- 结果以聚合形式返回，便于前端直接使用
2025-12-03 13:51:47,785 - services.graph_service - INFO - 查询验证通过
2025-12-03 13:51:47,792 - services.graph_service - INFO - 收到验证查询请求: MATCH (d:Disease {name: '肩痛'})
OPTIONAL MATCH (d)-[:recommand_drug|command_drug]-(drug:Drug)
OPTIONAL MATCH (d)-[:belongs_to]-(dept:Department)
OPTIONAL MATCH (d)-[:not_eat]-(food:Food)
RETURN 
  COLLECT(DISTINCT drug.name) AS recommended_drugs,
  COLLECT(DISTINCT dept.name) AS departments,
  COLLECT(DISTINCT food.name) AS avoid_foods
2025-12-03 13:51:47,793 - services.graph_service - INFO - 查询验证通过
2025-12-03 13:51:47,797 - services.graph_service - INFO - 收到执行查询请求: MATCH (d:Disease {name: '肩痛'})
OPTIONAL MATCH (d)-[:recommand_drug|command_drug]-(drug:Drug)
OPTIONAL MATCH (d)-[:belongs_to]-(dept:Department)
OPTIONAL MATCH (d)-[:not_eat]-(food:Food)
RETURN 
  COLLECT(DISTINCT drug.name) AS recommended_drugs,
  COLLECT(DISTINCT dept.name) AS departments,
  COLLECT(DISTINCT food.name) AS avoid_foods
2025-12-03 13:51:47,797 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (d:Disease {name: '肩痛'})
OPTIONAL MATCH (d)-[:recommand_drug|command_drug]-(drug:Drug)
OPTIONAL MATCH (d)-[:belongs_to]-(dept:Department)
OPTIONAL MATCH (d)-[:not_eat]-(food:Food)
RETURN 
  COLLECT(DISTINCT drug.name) AS recommended_drugs,
  COLLECT(DISTINCT dept.name) AS departments,
  COLLECT(DISTINCT food.name) AS avoid_foods
2025-12-03 13:51:47,895 - services.graph_service - INFO - 查询执行成功，耗时: 0.098秒，返回 1 条记录
2025-12-03 13:51:47,895 - services.graph_service - INFO - 查询执行完成，返回 1 条记录
2025-12-03 13:53:05,307 - services.graph_service - INFO - 收到生成查询请求: 感冒了有什么症状，有什么忌口，适合吃什么食物，我现在应该去那个科室进行治疗
2025-12-03 13:53:05,442 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 13:53:20,222 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (d:Disease {name: '感冒'})
OPTIONAL MATCH (d)-[:has_symptom]->(s:Symptom)
OPTIONAL MATCH (d)-[:not_eat]->(ne:Food)
OPTIONAL MATCH (d)-[:do_eat]->(de:Food)
OPTIONAL MATCH (d)-[:recommand_eat]->(re:Food)
OPTIONAL MATCH (d)-[:belongs_to]->(dep:Department)
RETURN 
    d.name AS disease_name,
    d.desc AS disease_description,
    COLLECT(DISTINCT s.name) AS symptoms,
    COLLECT(DISTINCT ne.name) AS avoid_foods,
    COLLECT(DISTINCT de.name) AS suitable_foods,
    COLLECT(DISTINCT re.name) AS recommended_foods,
    COLLECT(DISTINCT dep.name) AS departments
2025-12-03 13:53:20,271 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 13:53:37,547 - services.graph_service - INFO - 查询解释: 这个Cypher查询是用来从Neo4j图数据库中查找关于"感冒"这种疾病的详细信息。让我一步步解释：

## 查询目的
查找名为"感冒"的疾病及其相关症状、饮食建议和所属科室信息。

## 查询结构解析

### 1. **主匹配**
```cypher
MATCH (d:Disease {name: '感冒'})
```
- 查找标签为`Disease`的节点
- 条件是节点的`name`属性等于"感冒"
- 结果存储在变量`d`中

### 2. **多个可选匹配**
使用`OPTIONAL MATCH`来查找可能存在的相关关系：

- `(d)-[:has_symptom]->(s:Symptom)` - 查找感冒的症状
- `(d)-[:not_eat]->(ne:Food)` - 查找感冒期间应避免的食物
- `(d)-[:do_eat]->(de:Food)` - 查找感冒期间适合吃的食物
- `(d)-[:recommand_eat]->(re:Food)` - 查找感冒期间推荐的食物
- `(d)-[:belongs_to]->(dep:Department)` - 查找感冒所属的科室

### 3. **返回结果**
使用`COLLECT(DISTINCT ...)`将多个值聚合成数组：
- `disease_name` - 疾病名称
- `disease_description` - 疾病描述
- `symptoms` - 症状列表（数组）
- `avoid_foods` - 应避免的食物列表
- `suitable_foods` - 适合的食物列表
- `recommended_foods` - 推荐的食物列表
- `departments` - 所属科室列表

## 查询特点
- **OPTIONAL MATCH**：即使某些关系不存在，查询也不会失败，而是返回`null`或空数组
- **DISTINCT**：确保每个列表中不会有重复项
- **COLLECT**：将多个匹配的结果聚合成一个数组

## 预期结果
查询会返回一行数据，包含感冒的所有相关信息，每个关系类型的结果都会以数组形式展示。如果某些关系不存在，对应的数组会是空的。

这个查询非常适合医疗知识图谱应用，可以一次性获取疾病的完整信息。
2025-12-03 13:53:37,549 - services.graph_service - INFO - 查询验证通过
2025-12-03 13:53:37,559 - services.graph_service - INFO - 收到验证查询请求: MATCH (d:Disease {name: '感冒'})
OPTIONAL MATCH (d)-[:has_symptom]->(s:Symptom)
OPTIONAL MATCH (d)-[:not_eat]->(ne:Food)
OPTIONAL MATCH (d)-[:do_eat]->(de:Food)
OPTIONAL MATCH (d)-[:recommand_eat]->(re:Food)
OPTIONAL MATCH (d)-[:belongs_to]->(dep:Department)
RETURN 
    d.name AS disease_name,
    d.desc AS disease_description,
    COLLECT(DISTINCT s.name) AS symptoms,
    COLLECT(DISTINCT ne.name) AS avoid_foods,
    COLLECT(DISTINCT de.name) AS suitable_foods,
    COLLECT(DISTINCT re.name) AS recommended_foods,
    COLLECT(DISTINCT dep.name) AS departments
2025-12-03 13:53:37,559 - services.graph_service - INFO - 查询验证通过
2025-12-03 13:53:37,564 - services.graph_service - INFO - 收到执行查询请求: MATCH (d:Disease {name: '感冒'})
OPTIONAL MATCH (d)-[:has_symptom]->(s:Symptom)
OPTIONAL MATCH (d)-[:not_eat]->(ne:Food)
OPTIONAL MATCH (d)-[:do_eat]->(de:Food)
OPTIONAL MATCH (d)-[:recommand_eat]->(re:Food)
OPTIONAL MATCH (d)-[:belongs_to]->(dep:Department)
RETURN 
    d.name AS disease_name,
    d.desc AS disease_description,
    COLLECT(DISTINCT s.name) AS symptoms,
    COLLECT(DISTINCT ne.name) AS avoid_foods,
    COLLECT(DISTINCT de.name) AS suitable_foods,
    COLLECT(DISTINCT re.name) AS recommended_foods,
    COLLECT(DISTINCT dep.name) AS departments
2025-12-03 13:53:37,565 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (d:Disease {name: '感冒'})
OPTIONAL MATCH (d)-[:has_symptom]->(s:Symptom)
OPTIONAL MATCH (d)-[:not_eat]->(ne:Food)
OPTIONAL MATCH (d)-[:do_eat]->(de:Food)
OPTIONAL MATCH (d)-[:recommand_eat]->(re:Food)
OPTIONAL MATCH (d)-[:belongs_to]->(dep:Department)
RETURN 
    d.name AS disease_name,
    d.desc AS disease_description,
    COLLECT(DISTINCT s.name) AS symptoms,
    COLLECT(DISTINCT ne.name) AS avoid_foods,
    COLLECT(DISTINCT de.name) AS suitable_foods,
    COLLECT(DISTINCT re.name) AS recommended_foods,
    COLLECT(DISTINCT dep.name) AS departments
2025-12-03 13:53:37,717 - services.graph_service - INFO - 查询执行成功，耗时: 0.152秒，返回 1 条记录
2025-12-03 13:53:37,717 - services.graph_service - INFO - 查询执行完成，返回 1 条记录
2025-12-03 14:19:17,536 - services.graph_service - INFO - 收到生成查询请求: 藿香正气水可以治疗什么
2025-12-03 14:19:17,668 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 14:19:20,154 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (d:Drug)-[:recommand_drug]-(dis:Disease)
WHERE d.name = '藿香正气水'
RETURN dis.name AS disease_name
2025-12-03 14:19:20,200 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 14:19:31,816 - services.graph_service - INFO - 查询解释: 这个Cypher查询的作用是**查找与"藿香正气水"相关的疾病**。

让我详细解释一下：

## 查询结构解析：

1. **`MATCH (d:Drug)-[:recommand_drug]-(dis:Disease)`**
   - 匹配图数据库中的模式：一个"Drug"节点（药品）通过"recommand_drug"关系连接到一个"Disease"节点（疾病）
   - `d` 代表药品节点
   - `dis` 代表疾病节点
   - `:recommand_drug` 表示这两个节点之间的推荐关系

2. **`WHERE d.name = '藿香正气水'`**
   - 筛选条件：只查找名称为"藿香正气水"的药品

3. **`RETURN dis.name AS disease_name`**
   - 返回结果：所有与"藿香正气水"相关的疾病名称

## 通俗理解：
这个查询相当于问："**藿香正气水这个药，推荐用于治疗哪些疾病？**"

## 实际应用场景：
- 在医疗知识图谱中查找药品的适应症
- 药品推荐系统
- 医疗咨询系统

## 返回结果示例：
可能会返回类似这样的疾病名称：
- 中暑
- 肠胃不适
- 感冒
- 等等

这个查询对于了解药品的临床应用范围很有帮助。
2025-12-03 14:19:31,817 - services.graph_service - INFO - 查询验证通过
2025-12-03 14:19:31,832 - services.graph_service - INFO - 收到验证查询请求: MATCH (d:Drug)-[:recommand_drug]-(dis:Disease)
WHERE d.name = '藿香正气水'
RETURN dis.name AS disease_name
2025-12-03 14:19:31,833 - services.graph_service - INFO - 查询验证通过
2025-12-03 14:19:31,839 - services.graph_service - INFO - 收到执行查询请求: MATCH (d:Drug)-[:recommand_drug]-(dis:Disease)
WHERE d.name = '藿香正气水'
RETURN dis.name AS disease_name
2025-12-03 14:19:31,839 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (d:Drug)-[:recommand_drug]-(dis:Disease)
WHERE d.name = '藿香正气水'
RETURN dis.name AS disease_name
2025-12-03 14:19:31,893 - services.graph_service - INFO - 查询执行成功，耗时: 0.054秒，返回 6 条记录
2025-12-03 14:19:31,893 - services.graph_service - INFO - 查询执行完成，返回 6 条记录
2025-12-03 14:39:19,580 - services.graph_service - INFO - 收到生成查询请求: 有一种非常知名的止痛药有什么效果
2025-12-03 14:39:19,705 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 14:39:31,321 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (d:Drug)-[:recommand_drug|command_drug]-(dis:Disease)
WHERE d.name = '阿司匹林'
RETURN d.name AS drug_name, COLLECT(DISTINCT dis.name) AS treated_diseases
2025-12-03 14:39:31,394 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 14:39:46,232 - services.graph_service - INFO - 查询解释: 这个Cypher查询用于在Neo4j图数据库中查找与特定药物相关的疾病信息。让我详细解释一下：

## 查询功能
查找名为"阿司匹林"的药物可以治疗的所有疾病。

## 各部分解释：

1. **`MATCH (d:Drug)-[:recommand_drug|command_drug]-(dis:Disease)`**
   - 匹配模式：查找Drug节点和Disease节点之间的关系
   - `(d:Drug)`：标签为"Drug"的节点，别名为"d"
   - `(dis:Disease)`：标签为"Disease"的节点，别名为"dis"
   - `-[:recommand_drug|command_drug]-`：两种可能的关系类型（可能是拼写变体）
     - `recommand_drug`（推荐药物）
     - `command_drug`（可能是个拼写错误，本意可能是"recommend_drug"）

2. **`WHERE d.name = '阿司匹林'`**
   - 筛选条件：只选择名称为"阿司匹林"的药物节点

3. **`RETURN d.name AS drug_name, COLLECT(DISTINCT dis.name) AS treated_diseases`**
   - 返回结果：
     - `drug_name`：药物名称（阿司匹林）
     - `treated_diseases`：所有相关疾病的名称集合
     - `COLLECT(DISTINCT dis.name)`：收集所有不重复的疾病名称到一个列表中

## 查询结果示例：
```
drug_name | treated_diseases
----------|------------------
阿司匹林   | ["头痛", "发烧", "关节炎", "心脏病预防"]
```

## 简单来说：
这个查询回答的问题是："阿司匹林这个药可以治疗哪些疾病？"
2025-12-03 14:39:46,233 - services.graph_service - INFO - 查询验证通过
2025-12-03 14:39:46,243 - services.graph_service - INFO - 收到验证查询请求: MATCH (d:Drug)-[:recommand_drug|command_drug]-(dis:Disease)
WHERE d.name = '阿司匹林'
RETURN d.name AS drug_name, COLLECT(DISTINCT dis.name) AS treated_diseases
2025-12-03 14:39:46,243 - services.graph_service - INFO - 查询验证通过
2025-12-03 14:39:46,249 - services.graph_service - INFO - 收到执行查询请求: MATCH (d:Drug)-[:recommand_drug|command_drug]-(dis:Disease)
WHERE d.name = '阿司匹林'
RETURN d.name AS drug_name, COLLECT(DISTINCT dis.name) AS treated_diseases
2025-12-03 14:39:46,249 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (d:Drug)-[:recommand_drug|command_drug]-(dis:Disease)
WHERE d.name = '阿司匹林'
RETURN d.name AS drug_name, COLLECT(DISTINCT dis.name) AS treated_diseases
2025-12-03 14:39:46,324 - services.graph_service - INFO - 查询执行成功，耗时: 0.075秒，返回 0 条记录
2025-12-03 14:39:46,324 - services.graph_service - INFO - 查询执行完成，返回 0 条记录
2025-12-03 14:48:46,835 - services.graph_service - INFO - 收到生成查询请求: 吉春制药轻身消胖丸是那个厂商制作的有什么疗效
2025-12-03 14:48:46,941 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 14:48:58,686 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (d:Drug)-[:drugs_of]->(p:Producer)
WHERE d.name = '吉春制药轻身消胖丸'
RETURN d.name AS drug_name, p.name AS producer_name
MATCH (d:Drug)<-[:recommand_drug]-(dis:Disease)
WHERE d.name = '吉春制药轻身消胖丸'
RETURN d.name AS drug_name, COLLECT(DISTINCT dis.name) AS treated_diseases
2025-12-03 14:48:58,735 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 14:49:19,683 - services.graph_service - INFO - 查询解释: 这个Cypher查询由两个独立的`MATCH`语句组成，用于从Neo4j图数据库中检索关于特定药品的信息。让我分别解释：

## 第一个查询部分：
```cypher
MATCH (d:Drug)-[:drugs_of]->(p:Producer)
WHERE d.name = '吉春制药轻身消胖丸'
RETURN d.name AS drug_name, p.name AS producer_name
```

**解释：**
- 查找名为"吉春制药轻身消胖丸"的药品节点（标签为`Drug`）
- 沿着`drugs_of`关系找到该药品的生产商节点（标签为`Producer`）
- 返回药品名称和生产商名称

**结果示例：**
```
drug_name                    | producer_name
-----------------------------|--------------
吉春制药轻身消胖丸          | 吉春制药公司
```

## 第二个查询部分：
```cypher
MATCH (d:Drug)<-[:recommand_drug]-(dis:Disease)
WHERE d.name = '吉春制药轻身消胖丸'
RETURN d.name AS drug_name, COLLECT(DISTINCT dis.name) AS treated_diseases
```

**解释：**
- 查找名为"吉春制药轻身消胖丸"的药品节点
- 查找所有通过`recommand_drug`关系推荐该药品的疾病节点（标签为`Disease`）
- 使用`COLLECT(DISTINCT dis.name)`将所有疾病名称收集到一个列表中（去重）
- 返回药品名称和它治疗的所有疾病列表

**结果示例：**
```
drug_name                    | treated_diseases
-----------------------------|------------------
吉春制药轻身消胖丸          | ["肥胖症", "代谢综合征", "体重管理"]
```

## 总体目的：
这个查询获取"吉春制药轻身消胖丸"的两方面信息：
1. 它的生产商是谁
2. 它能治疗哪些疾病

**注意：** 这两个查询是独立的，会返回两个结果集。如果你想在一个结果中同时获取这两类信息，可以使用单个查询：

```cypher
MATCH (d:Drug {name: '吉春制药轻身消胖丸'})
OPTIONAL MATCH (d)-[:drugs_of]->(p:Producer)
OPTIONAL MATCH (d)<-[:recommand_drug]-(dis:Disease)
RETURN d.name AS drug_name, 
       p.name AS producer_name,
       COLLECT(DISTINCT dis.name) AS treated_diseases
```
2025-12-03 14:49:19,684 - services.graph_service - INFO - 查询验证通过
2025-12-03 14:49:19,689 - services.graph_service - INFO - 收到验证查询请求: MATCH (d:Drug)-[:drugs_of]->(p:Producer)
WHERE d.name = '吉春制药轻身消胖丸'
RETURN d.name AS drug_name, p.name AS producer_name
MATCH (d:Drug)<-[:recommand_drug]-(dis:Disease)
WHERE d.name = '吉春制药轻身消胖丸'
RETURN d.name AS drug_name, COLLECT(DISTINCT dis.name) AS treated_diseases
2025-12-03 14:49:19,689 - services.graph_service - INFO - 查询验证通过
2025-12-03 14:49:19,692 - services.graph_service - INFO - 收到执行查询请求: MATCH (d:Drug)-[:drugs_of]->(p:Producer)
WHERE d.name = '吉春制药轻身消胖丸'
RETURN d.name AS drug_name, p.name AS producer_name
MATCH (d:Drug)<-[:recommand_drug]-(dis:Disease)
WHERE d.name = '吉春制药轻身消胖丸'
RETURN d.name AS drug_name, COLLECT(DISTINCT dis.name) AS treated_diseases
2025-12-03 14:49:19,692 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (d:Drug)-[:drugs_of]->(p:Producer)
WHERE d.name = '吉春制药轻身消胖丸'
RETURN d.name AS drug_name, p.name AS producer_name
MATCH (d:Drug)<-[:recommand_drug]-(dis:Disease)
WHERE d.name = '吉春制药轻身消胖丸'
RETURN d.name AS drug_name, COLLECT(DISTINCT dis.name) AS treated_diseases
2025-12-03 14:49:19,727 - services.graph_service - ERROR - 查询执行失败，耗时: 0.035秒，错误: {code: Neo.ClientError.Statement.SyntaxError} {message: RETURN can only be used at the end of the query. (line 3, column 1 (offset: 68))
"RETURN d.name AS drug_name, p.name AS producer_name"
 ^}
2025-12-03 14:55:44,994 - services.graph_service - INFO - Neo4j 连接已关闭
2025-12-03 14:55:47,657 - services.graph_service - INFO - 成功连接到 Neo4j: neo4j://0.0.0.0:7687
2025-12-03 14:56:01,690 - services.graph_service - INFO - 收到生成查询请求: 吉春制药轻身消胖丸是那个厂商制作的有什么疗效
2025-12-03 14:56:02,133 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 14:56:04,841 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (d:Drug)-[:drugs_of]->(p:Producer)
WHERE d.name = '吉春制药轻身消胖丸'
RETURN p.name AS producer_name
2025-12-03 14:56:04,927 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 14:56:14,981 - services.graph_service - INFO - 查询解释: 这个Cypher查询的作用是**查找生产特定药品的厂商名称**。

让我一步步解释：

1. **`MATCH (d:Drug)-[:drugs_of]->(p:Producer)`**
   - 在图中查找所有"Drug"节点（用`d`表示）和"Producer"节点（用`p`表示）
   - 这些节点之间通过`drugs_of`关系连接，方向是从药品指向生产商

2. **`WHERE d.name = '吉春制药轻身消胖丸'`**
   - 筛选条件：只查找名称为"吉春制药轻身消胖丸"的药品节点

3. **`RETURN p.name AS producer_name`**
   - 返回结果：获取匹配到的生产商节点的名称，并命名为`producer_name`

**简单来说**：这个查询就是问"谁生产了'吉春制药轻身消胖丸'这个药？"，然后返回生产商的名字。

**查询结果**：会返回一个包含`producer_name`字段的结果，显示生产该药品的厂商名称。
2025-12-03 14:56:14,983 - services.graph_service - INFO - 查询验证通过
2025-12-03 14:56:14,996 - services.graph_service - INFO - 收到验证查询请求: MATCH (d:Drug)-[:drugs_of]->(p:Producer)
WHERE d.name = '吉春制药轻身消胖丸'
RETURN p.name AS producer_name
2025-12-03 14:56:14,997 - services.graph_service - INFO - 查询验证通过
2025-12-03 14:56:15,003 - services.graph_service - INFO - 收到执行查询请求: MATCH (d:Drug)-[:drugs_of]->(p:Producer)
WHERE d.name = '吉春制药轻身消胖丸'
RETURN p.name AS producer_name
2025-12-03 14:56:15,003 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (d:Drug)-[:drugs_of]->(p:Producer)
WHERE d.name = '吉春制药轻身消胖丸'
RETURN p.name AS producer_name
2025-12-03 14:56:15,102 - neo4j.notifications - WARNING - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownRelationshipTypeWarning} {category: UNRECOGNIZED} {title: The provided relationship type is not in the database.} {description: One of the relationship types in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing relationship type is: drugs_of)} {position: line: 1, column: 18, offset: 17} for query: "MATCH (d:Drug)-[:drugs_of]->(p:Producer)\nWHERE d.name = '吉春制药轻身消胖丸'\nRETURN p.name AS producer_name"
2025-12-03 14:56:15,103 - services.graph_service - INFO - 查询执行成功，耗时: 0.099秒，返回 0 条记录
2025-12-03 14:56:15,103 - services.graph_service - INFO - 查询执行完成，返回 0 条记录
2025-12-03 14:58:09,159 - services.graph_service - INFO - 收到生成查询请求: 高血压应该什么检查
2025-12-03 14:58:09,298 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 14:58:11,707 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (d:Disease)-[:need_check]->(c:Check) 
WHERE d.name = '高血压' 
RETURN c.name
2025-12-03 14:58:11,750 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 14:58:21,977 - services.graph_service - INFO - 查询解释: 这个Cypher查询是用来从Neo4j图数据库中查找与"高血压"疾病相关的检查项目。

让我一步步解释：

1. **MATCH (d:Disease)-[:need_check]->(c:Check)**
   - 匹配一个模式：找到所有标签为"Disease"的节点（用d表示），这些节点通过"need_check"关系连接到标签为"Check"的节点（用c表示）
   - 这表示"疾病需要检查"的关系

2. **WHERE d.name = '高血压'**
   - 筛选条件：只选择疾病名称为"高血压"的疾病节点

3. **RETURN c.name**
   - 返回结果：只返回检查项目的名称

**简单来说**：这个查询的意思是"找出高血压需要做的所有检查项目"。

**查询结果**：会返回一个检查项目名称的列表，比如可能包括"血压测量"、"心电图"、"血液检查"等。

这种查询在医疗知识图谱中很常见，可以帮助医生或患者了解某种疾病需要做哪些检查。
2025-12-03 14:58:21,978 - services.graph_service - INFO - 查询验证通过
2025-12-03 14:58:21,987 - services.graph_service - INFO - 收到验证查询请求: MATCH (d:Disease)-[:need_check]->(c:Check) 
WHERE d.name = '高血压' 
RETURN c.name
2025-12-03 14:58:21,987 - services.graph_service - INFO - 查询验证通过
2025-12-03 14:58:21,990 - services.graph_service - INFO - 收到执行查询请求: MATCH (d:Disease)-[:need_check]->(c:Check) 
WHERE d.name = '高血压' 
RETURN c.name
2025-12-03 14:58:21,990 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (d:Disease)-[:need_check]->(c:Check) 
WHERE d.name = '高血压' 
RETURN c.name
2025-12-03 14:58:22,023 - services.graph_service - INFO - 查询执行成功，耗时: 0.033秒，返回 10 条记录
2025-12-03 14:58:22,024 - services.graph_service - INFO - 查询执行完成，返回 10 条记录
2025-12-03 15:00:51,568 - services.graph_service - INFO - 收到生成查询请求: 和阿司匹里效果相似的药
2025-12-03 15:00:51,689 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 15:00:54,349 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (d:Drug)-[:drugs_of]->(pr:Producer)
WHERE d.name = '阿司匹林'
RETURN pr.name
2025-12-03 15:00:54,408 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 15:01:08,030 - services.graph_service - INFO - 查询解释: 这个Cypher查询的作用是**查找生产"阿司匹林"药品的厂商名称**。

让我一步步解释：

1. **`MATCH (d:Drug)-[:drugs_of]->(pr:Producer)`**
   - 匹配图数据库中的节点和关系
   - `(d:Drug)`：查找标签为"Drug"（药品）的节点，给它们起别名"d"
   - `(pr:Producer)`：查找标签为"Producer"（生产商）的节点，起别名"pr"
   - `-[:drugs_of]->`：查找从药品节点指向生产商节点的"drugs_of"关系（表示"属于...的药品"）

2. **`WHERE d.name = '阿司匹林'`**
   - 筛选条件：只选择药品名称为"阿司匹林"的节点

3. **`RETURN pr.name`**
   - 返回结果：只返回生产商节点的名称属性

**简单来说**：这个查询就像是在问数据库："哪些公司生产阿司匹林？请告诉我这些公司的名字。"

**查询结果示例**：
```
┌───────────┐
│ pr.name   │
├───────────┤
│ 拜耳公司   │
│ 华北制药   │
└───────────┘
```

这个查询假设你的图数据库中已经建立了药品和生产商之间的关系，通过这个查询可以快速找到特定药品的生产厂商信息。
2025-12-03 15:01:08,032 - services.graph_service - INFO - 查询验证通过
2025-12-03 15:01:08,041 - services.graph_service - INFO - 收到验证查询请求: MATCH (d:Drug)-[:drugs_of]->(pr:Producer)
WHERE d.name = '阿司匹林'
RETURN pr.name
2025-12-03 15:01:08,041 - services.graph_service - INFO - 查询验证通过
2025-12-03 15:01:08,047 - services.graph_service - INFO - 收到执行查询请求: MATCH (d:Drug)-[:drugs_of]->(pr:Producer)
WHERE d.name = '阿司匹林'
RETURN pr.name
2025-12-03 15:01:08,048 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (d:Drug)-[:drugs_of]->(pr:Producer)
WHERE d.name = '阿司匹林'
RETURN pr.name
2025-12-03 15:01:08,114 - neo4j.notifications - WARNING - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownRelationshipTypeWarning} {category: UNRECOGNIZED} {title: The provided relationship type is not in the database.} {description: One of the relationship types in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing relationship type is: drugs_of)} {position: line: 1, column: 18, offset: 17} for query: "MATCH (d:Drug)-[:drugs_of]->(pr:Producer)\nWHERE d.name = '阿司匹林'\nRETURN pr.name"
2025-12-03 15:01:08,114 - services.graph_service - INFO - 查询执行成功，耗时: 0.066秒，返回 0 条记录
2025-12-03 15:01:08,114 - services.graph_service - INFO - 查询执行完成，返回 0 条记录
2025-12-03 15:20:40,757 - services.graph_service - INFO - Neo4j 连接已关闭
2025-12-03 15:30:33,481 - services.graph_service - INFO - 成功连接到 Neo4j: neo4j://0.0.0.0:7687
2025-12-03 15:30:49,246 - services.graph_service - INFO - 收到生成查询请求: 传染性疾病有哪些
2025-12-03 15:30:49,624 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 15:30:52,024 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (d:Disease) 
WHERE d.get_way CONTAINS '传染' 
RETURN d.name, d.get_way
2025-12-03 15:30:52,066 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 15:31:05,237 - services.graph_service - INFO - 查询解释: 这个Cypher查询用于在Neo4j图数据库中查找并返回特定类型的疾病信息。让我逐步解释：

**查询目的：**
查找所有通过"传染"途径传播的疾病，并返回这些疾病的名称和传播方式。

**具体步骤：**

1. **`MATCH (d:Disease)`**
   - 匹配所有标签为"Disease"（疾病）的节点
   - 给这些节点起一个别名"d"以便后续引用

2. **`WHERE d.get_way CONTAINS '传染'`**
   - 筛选条件：只选择那些"get_way"属性中包含"传染"二字的疾病节点
   - `get_way`可能是表示"传播途径"或"感染方式"的属性
   - `CONTAINS`是字符串包含操作，类似模糊搜索

3. **`RETURN d.name, d.get_way`**
   - 返回结果：每个匹配疾病的名称(name)和传播方式(get_way)

**简单来说：**
这个查询相当于问："请告诉我所有通过传染方式传播的疾病名称和它们的具体传播途径。"

**示例结果可能包括：**
- 流感（飞沫传染）
- 肺结核（空气传染）
- 艾滋病（血液传染）

这个查询在医疗知识图谱、疾病数据库或公共卫生系统中很有用，可以帮助快速识别传染性疾病。
2025-12-03 15:31:05,239 - services.graph_service - INFO - 查询验证通过
2025-12-03 15:31:05,252 - services.graph_service - INFO - 收到验证查询请求: MATCH (d:Disease) 
WHERE d.get_way CONTAINS '传染' 
RETURN d.name, d.get_way
2025-12-03 15:31:05,253 - services.graph_service - INFO - 查询验证通过
2025-12-03 15:31:05,259 - services.graph_service - INFO - 收到执行查询请求: MATCH (d:Disease) 
WHERE d.get_way CONTAINS '传染' 
RETURN d.name, d.get_way
2025-12-03 15:31:05,259 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (d:Disease) 
WHERE d.get_way CONTAINS '传染' 
RETURN d.name, d.get_way
2025-12-03 15:31:05,358 - services.graph_service - INFO - 查询执行成功，耗时: 0.098秒，返回 942 条记录
2025-12-03 15:31:05,358 - services.graph_service - INFO - 查询执行完成，返回 942 条记录
2025-12-03 15:32:02,610 - services.graph_service - INFO - 收到生成查询请求: 查找医保覆盖的疾病有哪些?
2025-12-03 15:32:02,796 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 15:32:05,292 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (d:Disease) 
WHERE d.yibao_status = '是' 
RETURN d.name AS disease_name, d.yibao_status AS yibao_status
2025-12-03 15:32:05,347 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 15:32:18,598 - services.graph_service - INFO - 查询解释: 这个Cypher查询的作用是从图数据库中查找并返回特定的疾病信息。让我详细解释一下：

**查询的组成部分：**

1. **`MATCH (d:Disease)`** 
   - 匹配所有带有"Disease"标签的节点
   - 给这些节点起了一个别名"d"，方便后续引用

2. **`WHERE d.yibao_status = '是'`**
   - 筛选条件：只选择那些"yibao_status"属性值为"是"的疾病节点
   - 这里"yibao_status"可能表示"医保状态"或类似含义

3. **`RETURN d.name AS disease_name, d.yibao_status AS yibao_status`**
   - 返回结果：显示疾病名称和医保状态
   - 使用"AS"给返回的列起更易读的别名

**简单来说，这个查询的意思是：**
"找出所有医保状态为'是'的疾病，并返回它们的名称和医保状态信息。"

**查询结果示例可能如下：**
```
disease_name    | yibao_status
----------------|-------------
高血压         | 是
糖尿病         | 是
冠心病         | 是
```

这个查询通常用于医疗或保险相关的系统中，用来筛选出哪些疾病被医保覆盖。
2025-12-03 15:32:18,599 - services.graph_service - INFO - 查询验证通过
2025-12-03 15:32:18,609 - services.graph_service - INFO - 收到验证查询请求: MATCH (d:Disease) 
WHERE d.yibao_status = '是' 
RETURN d.name AS disease_name, d.yibao_status AS yibao_status
2025-12-03 15:32:18,609 - services.graph_service - INFO - 查询验证通过
2025-12-03 15:32:18,613 - services.graph_service - INFO - 收到执行查询请求: MATCH (d:Disease) 
WHERE d.yibao_status = '是' 
RETURN d.name AS disease_name, d.yibao_status AS yibao_status
2025-12-03 15:32:18,613 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (d:Disease) 
WHERE d.yibao_status = '是' 
RETURN d.name AS disease_name, d.yibao_status AS yibao_status
2025-12-03 15:32:18,637 - services.graph_service - INFO - 查询执行成功，耗时: 0.024秒，返回 0 条记录
2025-12-03 15:32:18,637 - services.graph_service - INFO - 查询执行完成，返回 0 条记录
2025-12-03 15:36:12,403 - services.graph_service - INFO - 收到生成查询请求: 查找治疗费用在8000-15000元的疾病有哪些?
2025-12-03 15:36:12,603 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 15:36:15,852 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (d:Disease) 
WHERE d.cost_money CONTAINS '8000' OR d.cost_money CONTAINS '15000' 
RETURN d.name, d.cost_money
2025-12-03 15:36:15,897 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 15:36:33,516 - services.graph_service - INFO - 查询解释: 这个Cypher查询是用来在Neo4j图数据库中查找特定疾病信息的。让我一步步解释：

## 查询的作用：
查找那些治疗费用包含"8000"或"15000"这两个数字的疾病信息。

## 详细解释：

1. **`MATCH (d:Disease)`**
   - 匹配所有标签为"Disease"（疾病）的节点
   - 给这些节点起一个别名"d"，方便后续引用

2. **`WHERE d.cost_money CONTAINS '8000' OR d.cost_money CONTAINS '15000'`**
   - 筛选条件：只选择那些`cost_money`属性包含"8000"或"15000"的疾病节点
   - `CONTAINS`是字符串包含操作，检查属性值中是否包含指定的子字符串
   - `OR`表示两个条件满足任意一个即可

3. **`RETURN d.name, d.cost_money`**
   - 返回结果：只显示疾病的名称(`name`)和治疗费用(`cost_money`)

## 举个例子：
假设数据库中有这些疾病节点：
- 疾病A：`cost_money = "约8000-10000元"`
- 疾病B：`cost_money = "15000元左右"`
- 疾病C：`cost_money = "5000元"`

查询结果会返回：
- 疾病A（包含8000）
- 疾病B（包含15000）
- 疾病C不会被返回（不包含8000或15000）

## 注意事项：
- 这个查询是基于**文本匹配**，不是数值比较
- 如果`cost_money`是数值类型而不是字符串，这个查询可能不会按预期工作
- 查询会找到任何位置包含这些数字的费用描述，比如"约8000元"、"15000-20000元"等都会被匹配到
2025-12-03 15:36:33,518 - services.graph_service - INFO - 查询验证通过
2025-12-03 15:36:33,523 - services.graph_service - INFO - 收到验证查询请求: MATCH (d:Disease) 
WHERE d.cost_money CONTAINS '8000' OR d.cost_money CONTAINS '15000' 
RETURN d.name, d.cost_money
2025-12-03 15:36:33,523 - services.graph_service - INFO - 查询验证通过
2025-12-03 15:36:33,527 - services.graph_service - INFO - 收到执行查询请求: MATCH (d:Disease) 
WHERE d.cost_money CONTAINS '8000' OR d.cost_money CONTAINS '15000' 
RETURN d.name, d.cost_money
2025-12-03 15:36:33,527 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (d:Disease) 
WHERE d.cost_money CONTAINS '8000' OR d.cost_money CONTAINS '15000' 
RETURN d.name, d.cost_money
2025-12-03 15:36:33,582 - services.graph_service - INFO - 查询执行成功，耗时: 0.054秒，返回 158 条记录
2025-12-03 15:36:33,582 - services.graph_service - INFO - 查询执行完成，返回 158 条记录
2025-12-03 15:45:22,492 - services.graph_service - INFO - 收到生成查询请求: 感冒了有什么症状？去哪个科室，治疗费用大概是多少
2025-12-03 15:45:22,639 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 15:45:27,773 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (d:Disease {name: '感冒'})
OPTIONAL MATCH (d)-[:has_symptom]->(s:Symptom)
OPTIONAL MATCH (d)-[:belongs_to]->(dept:Department)
RETURN 
  d.name AS disease_name,
  d.cost_money AS treatment_cost,
  COLLECT(DISTINCT s.name) AS symptoms,
  COLLECT(DISTINCT dept.name) AS departments
2025-12-03 15:45:27,820 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 15:45:47,026 - services.graph_service - INFO - 查询解释: 这个Cypher查询是用来从Neo4j图数据库中查找关于"感冒"这种疾病的相关信息。让我一步步解释：

## 查询目的
查找"感冒"这种疾病的详细信息，包括治疗费用、相关症状和所属科室。

## 查询分解

1. **`MATCH (d:Disease {name: '感冒'})`**
   - 找到标签为"Disease"（疾病）的节点
   - 且该节点的name属性值为"感冒"
   - 将这个节点赋值给变量`d`

2. **`OPTIONAL MATCH (d)-[:has_symptom]->(s:Symptom)`**
   - 可选匹配：查找与疾病节点`d`通过"has_symptom"关系连接的所有症状节点
   - 将这些症状节点赋值给变量`s`
   - 使用`OPTIONAL`表示即使没有相关症状，查询也会继续执行

3. **`OPTIONAL MATCH (d)-[:belongs_to]->(dept:Department)`**
   - 可选匹配：查找与疾病节点`d`通过"belongs_to"关系连接的所有科室节点
   - 将这些科室节点赋值给变量`dept`

4. **`RETURN`部分**：
   - `d.name AS disease_name`：返回疾病名称
   - `d.cost_money AS treatment_cost`：返回治疗费用
   - `COLLECT(DISTINCT s.name) AS symptoms`：将所有不重复的症状名称收集成一个列表
   - `COLLECT(DISTINCT dept.name) AS departments`：将所有不重复的科室名称收集成一个列表

## 预期结果
查询会返回一行数据，包含：
- 疾病名称（"感冒"）
- 治疗费用
- 所有相关症状的列表（如：["发烧", "咳嗽", "流鼻涕"]）
- 所有相关科室的列表（如：["内科", "呼吸科"]）

## 使用场景
这种查询在医疗知识图谱中很常见，可以帮助：
- 患者了解疾病信息
- 医生快速获取疾病相关资料
- 医疗系统构建疾病知识库
2025-12-03 15:45:47,027 - services.graph_service - INFO - 查询验证通过
2025-12-03 15:45:47,038 - services.graph_service - INFO - 收到验证查询请求: MATCH (d:Disease {name: '感冒'})
OPTIONAL MATCH (d)-[:has_symptom]->(s:Symptom)
OPTIONAL MATCH (d)-[:belongs_to]->(dept:Department)
RETURN 
  d.name AS disease_name,
  d.cost_money AS treatment_cost,
  COLLECT(DISTINCT s.name) AS symptoms,
  COLLECT(DISTINCT dept.name) AS departments
2025-12-03 15:45:47,038 - services.graph_service - INFO - 查询验证通过
2025-12-03 15:45:47,044 - services.graph_service - INFO - 收到执行查询请求: MATCH (d:Disease {name: '感冒'})
OPTIONAL MATCH (d)-[:has_symptom]->(s:Symptom)
OPTIONAL MATCH (d)-[:belongs_to]->(dept:Department)
RETURN 
  d.name AS disease_name,
  d.cost_money AS treatment_cost,
  COLLECT(DISTINCT s.name) AS symptoms,
  COLLECT(DISTINCT dept.name) AS departments
2025-12-03 15:45:47,044 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (d:Disease {name: '感冒'})
OPTIONAL MATCH (d)-[:has_symptom]->(s:Symptom)
OPTIONAL MATCH (d)-[:belongs_to]->(dept:Department)
RETURN 
  d.name AS disease_name,
  d.cost_money AS treatment_cost,
  COLLECT(DISTINCT s.name) AS symptoms,
  COLLECT(DISTINCT dept.name) AS departments
2025-12-03 15:45:47,146 - services.graph_service - INFO - 查询执行成功，耗时: 0.102秒，返回 1 条记录
2025-12-03 15:45:47,147 - services.graph_service - INFO - 查询执行完成，返回 1 条记录
2025-12-03 15:58:35,352 - services.graph_service - INFO - 收到生成查询请求: 高血压患者饮食要注意什么？
2025-12-03 15:58:35,523 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 15:58:38,877 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name='高血压' 
RETURN type(r) AS relationship_type, f.name AS food_name
2025-12-03 15:58:38,924 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 15:58:54,138 - services.graph_service - INFO - 查询解释: 这个Cypher查询是用来在Neo4j图数据库中查找与"高血压"相关的食物信息的。让我一步步解释：

## 查询目的
查找所有与"高血压"疾病相关的食物，并显示它们之间的关系类型和食物名称。

## 查询分解

1. **`MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food)`**
   - 匹配疾病节点和食物节点之间的三种可能关系：
     - `not_eat`：不应该吃的食物
     - `do_eat`：可以吃的食物  
     - `recommand_eat`：推荐吃的食物
   - `d` 代表疾病节点（标签为 Disease）
   - `f` 代表食物节点（标签为 Food）
   - `r` 代表它们之间的关系

2. **`WHERE d.name='高血压'`**
   - 筛选条件：只查找名称为"高血压"的疾病

3. **`RETURN type(r) AS relationship_type, f.name AS food_name`**
   - 返回结果包含两列：
     - `relationship_type`：关系类型（not_eat、do_eat或recommand_eat）
     - `food_name`：食物名称

## 查询结果示例
可能会返回类似这样的结果：
```
relationship_type | food_name
-----------------|-----------
not_eat          | 咸菜
do_eat           | 苹果
recommand_eat    | 芹菜
```

## 简单理解
这个查询相当于问："对于高血压患者，哪些食物是不应该吃的、可以吃的和推荐吃的？"
2025-12-03 15:58:54,139 - services.graph_service - INFO - 查询验证通过
2025-12-03 15:58:54,150 - services.graph_service - INFO - 收到验证查询请求: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name='高血压' 
RETURN type(r) AS relationship_type, f.name AS food_name
2025-12-03 15:58:54,150 - services.graph_service - INFO - 查询验证通过
2025-12-03 15:58:54,154 - services.graph_service - INFO - 收到执行查询请求: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name='高血压' 
RETURN type(r) AS relationship_type, f.name AS food_name
2025-12-03 15:58:54,155 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name='高血压' 
RETURN type(r) AS relationship_type, f.name AS food_name
2025-12-03 15:58:54,237 - services.graph_service - INFO - 查询执行成功，耗时: 0.082秒，返回 22 条记录
2025-12-03 15:58:54,237 - services.graph_service - INFO - 查询执行完成，返回 22 条记录
2025-12-03 15:59:56,470 - services.graph_service - INFO - 收到生成查询请求: 肩痛应该怎么治疗？
2025-12-03 15:59:56,617 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 16:00:00,411 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (d:Disease)-[:has_symptom]->(s:Symptom)
WHERE s.name CONTAINS '肩痛'
MATCH (d)-[:treated_by]->(t:Treatment)
RETURN d.name AS disease_name, COLLECT(DISTINCT t.name) AS treatments
2025-12-03 16:00:00,466 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 16:00:19,757 - services.graph_service - INFO - 查询解释: 这个Cypher查询用于从医疗知识图谱中查找与"肩痛"相关的疾病及其治疗方法。让我详细解释每个部分：

## 查询目的
找出所有具有"肩痛"症状的疾病，并返回这些疾病对应的治疗方法。

## 查询分解

1. **`MATCH (d:Disease)-[:has_symptom]->(s:Symptom)`**
   - 匹配疾病节点（标签为Disease）和症状节点（标签为Symptom）之间的关系
   - `d`代表疾病节点变量
   - `s`代表症状节点变量
   - `has_symptom`是连接疾病和症状的关系类型

2. **`WHERE s.name CONTAINS '肩痛'`**
   - 筛选条件：只选择症状名称中包含"肩痛"的症状
   - 例如：会匹配"肩痛"、"左肩痛"、"慢性肩痛"等

3. **`MATCH (d)-[:treated_by]->(t:Treatment)`**
   - 对于上一步找到的每个疾病，再匹配其治疗方法
   - `t`代表治疗节点变量
   - `treated_by`是连接疾病和治疗的关系类型

4. **`RETURN d.name AS disease_name, COLLECT(DISTINCT t.name) AS treatments`**
   - 返回结果：
     - `disease_name`：疾病名称
     - `treatments`：该疾病的所有治疗方法列表（使用COLLECT聚合函数）
     - `DISTINCT`确保治疗方法不重复

## 查询结果示例
可能会返回类似这样的结果：
```
| disease_name | treatments                          |
|--------------|-------------------------------------|
| 肩周炎       | ["物理治疗", "药物治疗", "针灸"]    |
| 肩袖损伤     | ["手术治疗", "康复训练"]            |
```

## 简单总结
这个查询相当于问："哪些疾病会有肩痛症状？这些疾病分别有哪些治疗方法？"
2025-12-03 16:00:19,758 - services.graph_service - INFO - 查询验证通过
2025-12-03 16:00:19,774 - services.graph_service - INFO - 收到验证查询请求: MATCH (d:Disease)-[:has_symptom]->(s:Symptom)
WHERE s.name CONTAINS '肩痛'
MATCH (d)-[:treated_by]->(t:Treatment)
RETURN d.name AS disease_name, COLLECT(DISTINCT t.name) AS treatments
2025-12-03 16:00:19,774 - services.graph_service - INFO - 查询验证通过
2025-12-03 16:00:19,782 - services.graph_service - INFO - 收到执行查询请求: MATCH (d:Disease)-[:has_symptom]->(s:Symptom)
WHERE s.name CONTAINS '肩痛'
MATCH (d)-[:treated_by]->(t:Treatment)
RETURN d.name AS disease_name, COLLECT(DISTINCT t.name) AS treatments
2025-12-03 16:00:19,782 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (d:Disease)-[:has_symptom]->(s:Symptom)
WHERE s.name CONTAINS '肩痛'
MATCH (d)-[:treated_by]->(t:Treatment)
RETURN d.name AS disease_name, COLLECT(DISTINCT t.name) AS treatments
2025-12-03 16:00:19,845 - services.graph_service - INFO - 查询执行成功，耗时: 0.063秒，返回 1 条记录
2025-12-03 16:00:19,846 - services.graph_service - INFO - 查询执行完成，返回 1 条记录
2025-12-03 16:02:55,969 - services.graph_service - INFO - 收到生成查询请求: 保和丸能治疗什么疾病？
2025-12-03 16:02:56,156 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 16:02:59,204 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (d:Drug)-[:recommand_drug|command_drug]-(dis:Disease) 
WHERE d.name = '保和丸' 
RETURN dis.name AS disease_name
2025-12-03 16:02:59,402 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 16:03:16,047 - services.graph_service - INFO - 查询解释: 这个Cypher查询用于在Neo4j图数据库中查找与特定药物相关的疾病信息。让我详细解释一下：

## 查询目的
查找与名为"保和丸"的药物相关的所有疾病。

## 查询分解

1. **`MATCH (d:Drug)-[:recommand_drug|command_drug]-(dis:Disease)`**
   - 匹配模式：查找Drug节点和Disease节点之间的关系
   - `(d:Drug)`：标签为"Drug"的节点，别名为"d"
   - `(dis:Disease)`：标签为"Disease"的节点，别名为"dis"
   - `-[:recommand_drug|command_drug]-`：两种可能的关系类型：
     - `recommand_drug`（推荐药物）
     - `command_drug`（可能是个拼写错误，应该是"recommend_drug"）

2. **`WHERE d.name = '保和丸'`**
   - 筛选条件：只选择名称为"保和丸"的Drug节点

3. **`RETURN dis.name AS disease_name`**
   - 返回结果：返回所有相关疾病的名称，并将结果列命名为"disease_name"

## 查询结果
这个查询会返回一个列表，包含所有通过`recommand_drug`或`command_drug`关系与"保和丸"药物相关联的疾病名称。

## 实际应用场景
这种查询在医疗知识图谱中很常见，可以用于：
- 查找某种药物的适应症
- 分析药物与疾病的关系
- 构建药物推荐系统

注意：查询中的`command_drug`可能是`recommend_drug`的拼写错误，在实际数据库中需要确认关系类型的准确名称。
2025-12-03 16:03:16,048 - services.graph_service - INFO - 查询验证通过
2025-12-03 16:03:16,055 - services.graph_service - INFO - 收到验证查询请求: MATCH (d:Drug)-[:recommand_drug|command_drug]-(dis:Disease) 
WHERE d.name = '保和丸' 
RETURN dis.name AS disease_name
2025-12-03 16:03:16,055 - services.graph_service - INFO - 查询验证通过
2025-12-03 16:03:16,060 - services.graph_service - INFO - 收到执行查询请求: MATCH (d:Drug)-[:recommand_drug|command_drug]-(dis:Disease) 
WHERE d.name = '保和丸' 
RETURN dis.name AS disease_name
2025-12-03 16:03:16,060 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (d:Drug)-[:recommand_drug|command_drug]-(dis:Disease) 
WHERE d.name = '保和丸' 
RETURN dis.name AS disease_name
2025-12-03 16:03:16,135 - services.graph_service - INFO - 查询执行成功，耗时: 0.075秒，返回 8 条记录
2025-12-03 16:03:16,135 - services.graph_service - INFO - 查询执行完成，返回 8 条记录
2025-12-03 16:08:13,334 - services.graph_service - INFO - 收到生成查询请求: 高血压患者饮食要注意什么？可以使用什么进行治疗？治疗费用大概是多少？
2025-12-03 16:08:13,457 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 16:08:22,323 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (d:Disease {name: '高血压'})
OPTIONAL MATCH (d)-[r:not_eat|do_eat|recommand_eat]-(f:Food)
OPTIONAL MATCH (d)-[:treated_by]->(t:Treatment)
RETURN 
  d.name AS disease_name,
  d.cost_money AS treatment_cost,
  COLLECT(DISTINCT CASE 
    WHEN type(r) = 'not_eat' THEN '不能吃：' + f.name
    WHEN type(r) = 'do_eat' THEN '可以吃：' + f.name
    WHEN type(r) = 'recommand_eat' THEN '推荐吃：' + f.name
  END) AS dietary_notes,
  COLLECT(DISTINCT t.name) AS treatments
2025-12-03 16:08:22,377 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 16:08:47,628 - services.graph_service - INFO - 查询解释: 这个Cypher查询是用来从Neo4j图数据库中查找关于"高血压"疾病的相关信息。让我一步步解释：

## 查询目的
查找名为"高血压"的疾病信息，包括治疗费用、饮食建议和治疗方法。

## 查询结构解析

### 1. **查找疾病节点**
```cypher
MATCH (d:Disease {name: '高血压'})
```
- 找到标签为`Disease`的节点
- 且该节点的`name`属性值为"高血压"
- 将这个节点用变量`d`表示

### 2. **查找相关食物（可选）**
```cypher
OPTIONAL MATCH (d)-[r:not_eat|do_eat|recommand_eat]-(f:Food)
```
- 查找与高血压相关的食物
- 关系类型有三种：`not_eat`（不能吃）、`do_eat`（可以吃）、`recommand_eat`（推荐吃）
- `OPTIONAL`表示即使没有找到相关食物，查询也会继续执行
- 找到的食物节点用变量`f`表示，关系用`r`表示

### 3. **查找治疗方法（可选）**
```cypher
OPTIONAL MATCH (d)-[:treated_by]->(t:Treatment)
```
- 查找高血压的治疗方法
- 通过`treated_by`关系连接到治疗节点
- 治疗节点用变量`t`表示

### 4. **返回结果**
```cypher
RETURN 
  d.name AS disease_name,
  d.cost_money AS treatment_cost,
  COLLECT(DISTINCT CASE 
    WHEN type(r) = 'not_eat' THEN '不能吃：' + f.name
    WHEN type(r) = 'do_eat' THEN '可以吃：' + f.name
    WHEN type(r) = 'recommand_eat' THEN '推荐吃：' + f.name
  END) AS dietary_notes,
  COLLECT(DISTINCT t.name) AS treatments
```

**返回的字段：**
- `disease_name`: 疾病名称（"高血压"）
- `treatment_cost`: 治疗费用
- `dietary_notes`: 饮食注意事项列表
  - 使用`CASE`语句根据关系类型添加前缀
  - `COLLECT(DISTINCT ...)`将结果收集为列表并去重
- `treatments`: 治疗方法列表

## 预期结果示例
查询可能返回类似这样的结果：
```
疾病名称：高血压
治疗费用：5000元
饮食建议：["不能吃：咸菜", "可以吃：芹菜", "推荐吃：香蕉"]
治疗方法：["药物治疗", "饮食控制", "定期运动"]
```

这个查询非常适合医疗健康领域的知识图谱应用，帮助患者了解疾病的全面信息。
2025-12-03 16:08:47,629 - services.graph_service - INFO - 查询验证通过
2025-12-03 16:08:47,635 - services.graph_service - INFO - 收到验证查询请求: MATCH (d:Disease {name: '高血压'})
OPTIONAL MATCH (d)-[r:not_eat|do_eat|recommand_eat]-(f:Food)
OPTIONAL MATCH (d)-[:treated_by]->(t:Treatment)
RETURN 
  d.name AS disease_name,
  d.cost_money AS treatment_cost,
  COLLECT(DISTINCT CASE 
    WHEN type(r) = 'not_eat' THEN '不能吃：' + f.name
    WHEN type(r) = 'do_eat' THEN '可以吃：' + f.name
    WHEN type(r) = 'recommand_eat' THEN '推荐吃：' + f.name
  END) AS dietary_notes,
  COLLECT(DISTINCT t.name) AS treatments
2025-12-03 16:08:47,635 - services.graph_service - INFO - 查询验证通过
2025-12-03 16:08:47,640 - services.graph_service - INFO - 收到执行查询请求: MATCH (d:Disease {name: '高血压'})
OPTIONAL MATCH (d)-[r:not_eat|do_eat|recommand_eat]-(f:Food)
OPTIONAL MATCH (d)-[:treated_by]->(t:Treatment)
RETURN 
  d.name AS disease_name,
  d.cost_money AS treatment_cost,
  COLLECT(DISTINCT CASE 
    WHEN type(r) = 'not_eat' THEN '不能吃：' + f.name
    WHEN type(r) = 'do_eat' THEN '可以吃：' + f.name
    WHEN type(r) = 'recommand_eat' THEN '推荐吃：' + f.name
  END) AS dietary_notes,
  COLLECT(DISTINCT t.name) AS treatments
2025-12-03 16:08:47,640 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (d:Disease {name: '高血压'})
OPTIONAL MATCH (d)-[r:not_eat|do_eat|recommand_eat]-(f:Food)
OPTIONAL MATCH (d)-[:treated_by]->(t:Treatment)
RETURN 
  d.name AS disease_name,
  d.cost_money AS treatment_cost,
  COLLECT(DISTINCT CASE 
    WHEN type(r) = 'not_eat' THEN '不能吃：' + f.name
    WHEN type(r) = 'do_eat' THEN '可以吃：' + f.name
    WHEN type(r) = 'recommand_eat' THEN '推荐吃：' + f.name
  END) AS dietary_notes,
  COLLECT(DISTINCT t.name) AS treatments
2025-12-03 16:08:47,757 - services.graph_service - INFO - 查询执行成功，耗时: 0.116秒，返回 1 条记录
2025-12-03 16:08:47,757 - services.graph_service - INFO - 查询执行完成，返回 1 条记录
2025-12-03 16:10:47,757 - services.graph_service - INFO - 收到生成查询请求: 高血压患者饮食要注意什么？
2025-12-03 16:10:48,067 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 16:10:51,168 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name='高血压' 
RETURN type(r) AS relationship_type, f.name AS food_name
2025-12-03 16:10:51,210 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 16:11:07,067 - services.graph_service - INFO - 查询解释: 这个Cypher查询是用来在Neo4j图数据库中查找与"高血压"相关的食物信息的。让我一步步解释：

## 查询目的
查找所有与"高血压"疾病相关的食物，并显示它们之间的关系类型和食物名称。

## 查询分解

1. **`MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food)`**
   - 匹配疾病节点和食物节点之间的三种可能关系：
     - `not_eat`：不应该吃的食物
     - `do_eat`：可以吃的食物  
     - `recommand_eat`：推荐吃的食物
   - `d` 代表疾病节点（标签为 Disease）
   - `f` 代表食物节点（标签为 Food）
   - `r` 代表它们之间的关系

2. **`WHERE d.name='高血压'`**
   - 筛选条件：只查找疾病名称为"高血压"的记录

3. **`RETURN type(r) AS relationship_type, f.name AS food_name`**
   - 返回结果包含两列：
     - `relationship_type`：关系类型（not_eat、do_eat或recommand_eat）
     - `food_name`：食物名称

## 查询结果示例
可能会返回类似这样的结果：
```
relationship_type | food_name
-----------------|-----------
not_eat          | 咸菜
do_eat           | 苹果
recommand_eat    | 芹菜
not_eat          | 肥肉
```

## 简单理解
这个查询相当于问："对于高血压患者，哪些食物是禁止吃的、可以吃的和推荐吃的？分别列出这些食物和对应的建议类型。"
2025-12-03 16:11:07,069 - services.graph_service - INFO - 查询验证通过
2025-12-03 16:11:07,080 - services.graph_service - INFO - 收到验证查询请求: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name='高血压' 
RETURN type(r) AS relationship_type, f.name AS food_name
2025-12-03 16:11:07,080 - services.graph_service - INFO - 查询验证通过
2025-12-03 16:11:07,086 - services.graph_service - INFO - 收到执行查询请求: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name='高血压' 
RETURN type(r) AS relationship_type, f.name AS food_name
2025-12-03 16:11:07,086 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (d:Disease)-[r:not_eat|do_eat|recommand_eat]-(f:Food) 
WHERE d.name='高血压' 
RETURN type(r) AS relationship_type, f.name AS food_name
2025-12-03 16:11:07,107 - services.graph_service - INFO - 查询执行成功，耗时: 0.021秒，返回 22 条记录
2025-12-03 16:11:07,108 - services.graph_service - INFO - 查询执行完成，返回 22 条记录
2025-12-03 16:11:42,554 - services.graph_service - INFO - 收到生成查询请求: 肩痛应该怎么治疗？
2025-12-03 16:11:42,662 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 16:11:45,863 - services.graph_service - INFO - 生成的 Cypher 查询: MATCH (d:Disease)-[:treated_by]->(t:Treatment) 
WHERE d.name = '肩痛' 
RETURN d.name AS disease_name, COLLECT(t.name) AS treatments
2025-12-03 16:11:45,904 - httpx - INFO - HTTP Request: POST https://api.deepseek.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-12-03 16:12:05,800 - services.graph_service - INFO - 查询解释: 这个Cypher查询是用来从Neo4j图数据库中查找与"肩痛"相关的治疗方法的。让我一步步解释：

## 查询的作用：
查找名为"肩痛"的疾病，并返回所有治疗这种疾病的方法。

## 各部分解释：

1. **`MATCH (d:Disease)-[:treated_by]->(t:Treatment)`**
   - 匹配图数据库中的模式
   - `d:Disease`：查找标签为"Disease"的节点，给它们起别名"d"
   - `t:Treatment`：查找标签为"Treatment"的节点，给它们起别名"t"
   - `-[:treated_by]->`：查找从疾病节点到治疗节点之间类型为"treated_by"的关系
   - 意思是：找到所有通过"treated_by"关系连接到治疗方法的疾病

2. **`WHERE d.name = '肩痛'`**
   - 筛选条件：只选择疾病名称(name属性)为"肩痛"的疾病节点

3. **`RETURN d.name AS disease_name, COLLECT(t.name) AS treatments`**
   - 返回结果：
     - `d.name AS disease_name`：疾病名称，重命名为"disease_name"
     - `COLLECT(t.name) AS treatments`：将所有匹配的治疗方法名称收集到一个列表中，重命名为"treatments"

## 简单来说：
这个查询的意思是："给我找一下叫'肩痛'的病，然后把所有能治这个病的方法都列出来，放在一个列表里。"

## 返回结果示例：
可能会返回这样的结果：
```
╔══════════════╦══════════════════════════════════════╗
║ disease_name ║ treatments                           ║
╠══════════════╬══════════════════════════════════════╣
║ 肩痛         ║ ["物理治疗", "药物治疗", "手术治疗"] ║
╚══════════════╩══════════════════════════════════════╝
```

这个查询在医疗知识图谱中很常见，可以帮助医生或患者快速了解某种疾病的所有可用治疗方法。
2025-12-03 16:12:05,802 - services.graph_service - INFO - 查询验证通过
2025-12-03 16:12:05,807 - services.graph_service - INFO - 收到验证查询请求: MATCH (d:Disease)-[:treated_by]->(t:Treatment) 
WHERE d.name = '肩痛' 
RETURN d.name AS disease_name, COLLECT(t.name) AS treatments
2025-12-03 16:12:05,807 - services.graph_service - INFO - 查询验证通过
2025-12-03 16:12:05,811 - services.graph_service - INFO - 收到执行查询请求: MATCH (d:Disease)-[:treated_by]->(t:Treatment) 
WHERE d.name = '肩痛' 
RETURN d.name AS disease_name, COLLECT(t.name) AS treatments
2025-12-03 16:12:05,811 - services.graph_service - INFO - 执行 Cypher 查询: MATCH (d:Disease)-[:treated_by]->(t:Treatment) 
WHERE d.name = '肩痛' 
RETURN d.name AS disease_name, COLLECT(t.name) AS treatments
2025-12-03 16:12:05,860 - services.graph_service - INFO - 查询执行成功，耗时: 0.049秒，返回 0 条记录
2025-12-03 16:12:05,860 - services.graph_service - INFO - 查询执行完成，返回 0 条记录
2025-12-03 16:36:29,030 - services.graph_service - INFO - Neo4j 连接已关闭
